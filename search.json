[{"title":"前端架构设计","url":"/2023/10/15/前端架构设计/","content":"## 模块分层架构：\n![项目结构分层](/img/ddd/项目结构分层.png)\n说明：\n- 数据访问层 DAL(Data Access Layer): api/vuex/localStorage 等，数据存储的接口，包括但不限于本地和后台存储   - 业务逻辑层 BLL(Business Logic Layer): detail/create/list 等，描述业务模型的场景和交互   - 控制层 Controller: router/layout/nav/pages 等，用于连接bll和page，配置访问路由\n\n- 视图层 Page: detail/create/list 等，各场景入口文件，统管内部所有组件   - 基础通用层 Common: utils/components 等，全局依赖\n设计核心原则：\n1. 业务逻辑和视图逻辑分离：bll聚焦在业务逻辑的数据获取、计算、合并等，而page、component则聚焦在页面的呈现结构实现上\n2. 单向依赖：不同层之间保持单向依赖关系，尽量避免跨层，反向依赖等情况出现，保证分层的边界明确，避免腐坏\n3. 相同层可以提取跨模块的共性进行优化：如page可以沉淀页面场景模板，controller提取通用layout和router模板，bll提取schema转换工具以适配通用的page和component等\n\n⠀目录文件组织结构：\n![目录文件组织结构](/img/ddd/目录文件组织结构.png)\n说明：\n1. 每个领域模型都按DCI组织方式设计\n2. bll最终按场景输出数据（initData）和交互行为（actions），模块场景不限于create/detail/list等常规场景，还可能包括跨模块引用的筛选弹窗、数据展示表格等\n\nDCI详细说明：\n- Data: 分为schema(fields、status等)以及data（通过api或内存中获取的form、table数据等）2类，最终会通过`initData`获取传递到page，在页面路由变更时会自动刷新，也可以在page通过emit事件主动刷\n- Context: Detail、Create、List等按场景组合Data和Interactive，作为领域模型对外使用的接口; 场景也可能会输出跨模块依赖 - Interactive: create、edit、getList、search、approval、getList等交互行为，归纳到`actions`，page通过emit进行交互，尽量保证单向数据流\n\nDCI强调2点：一是介于充血模型和贫血模型之间，简化模型同时又保留充血模型的便利（通过context来解耦，context可以注入不同的数据和行为组合）；二是补全MVC架构中缺少的交互描述\nDCI能够帮助DDD更有效的落地，在前端方面，可以让开发更易理解模型，让模型的表现形式更加具体（每个模型都包含data、interactive、context）\n\n### 跨模块场景示例：\n![跨模块场景](/img/ddd/跨模块场景.png)\n说明：\n* select sku dialog组件可能会被应用在pr模块，但sku展示的字段结构、search的api来源于SKU领域\n* PR的context可以引入SKU的context，PR和SKU通过各自的context来解耦\n\n⠀架构核心思想\n架构设计可能会一直迭代，但是核心思想不变：\n1. 将业务逻辑从组件中剥离出来，让组件的职责聚焦在结构的呈现和交互的多样性实现上，使组件变的灵活\n2. 从业务逻辑中提炼核心原型，使核心业务逻辑更稳定，寿命更长\n![核心思想](/img/ddd/核心思想.png)\n\n补充说明：\n当前架构借鉴了DDD的核心思想，但距离DDD最佳实践还有较大差距\nDDD最佳实践归纳：\n1. 构建通用语言：定领域模型之前应该先定义业务概念，并在后续过程中持续优化，能用共同语言描述的属于同一个领域\n2. 用通用语言划分领域的边界，构建领域模型\n3. 使用modules、entity、service、value object等构造模型\n4. 持续精炼领域模型，从通用语言和模型结构中提取核心原型，并通过上下文界定等方法保护核心原型不受边缘腐蚀\n5. 最终在多次迭代中实现一个兼具稳定性和扩展性的高质量系统\n","tags":["DDD"]},{"title":"关于DDD的前期调研和设想","url":"/2023/10/10/关于DDD的前期调研和设想/","content":"\n> 对于架构设计，我们先要理解软件的本质，有扎实的基础，才能真正落地，同时借鉴服务端、操作系统等经验，事半功倍。\n如果我看得更远一点的话，是因为我站在巨人的肩膀上。 ———— 牛顿\n\n## 一. 当前WEB前端所要去应对的场景是什么?\n可以总结为三大类:\n1. 业务系统\n2. 通用应用\n3. 工具类的应用\n\n⠀这三类可以统称为站点,或者是应用,最早的叫法是软件,我们可以从不同的角度去叫它,但表达的都是一个意思.\n1. 业务系统,比如说银行的客户管理系统,物流管理系统之类的,现在整个近十年趋势,都是从以前的CS架构转变成BS架构,所以大部分这种系统,都是以Web形式呈现的. 和通用应用不同的地方在于,业务系统更多的会用Web技术去做;\n2. 而通用应用一般不仅是web形式,安卓,ios各种设备都需要有\n3. 工具类的应用是指可以提供生产力的环境,比如你可以在上面做设计,快速获得各类报表;当下比较火的工具类应用类似Figma,百度地图\n\n⠀通过以上场景总结, **前端DDD更多地适合用于业务系统这类场景.**\n## 二. 关于目前主流前端框架的缺陷\n不知道你们有没有思考过这种问题: 特别是国内,用vue的同学非常的多.如果用vue的应用来开发业务系统,你会发现,当你写到第二年的时候,你就写不动了.因为很多用vue去做开发的应用,带有一种短频快; 或者是说,对开发者来讲,你进入这个项目待的时间不会特别长;当随着业务扩增和时间发展,会感觉代码非常混乱,在开发的时候,会在不同的文件,或者在各种组件上进行修改,那就会造成一个问题,就是开发者很难感知到我这个业务数据的变动,究竟是在什么时候触发的,除非很熟悉整个业务页面逻辑和代码结构,否则很难去维护.\n如果你是在做业务系统的程序员,你可能就要思考: **难道我只需要解决好数据驱动界面的问题,我就可以把业务写好了吗?**\n**主流框架便捷开发带来的坏处**\n很多时候,我们会将视图层的逻辑和业务层的逻辑杂糅在一起(比如说按钮的显隐逻辑写template里),你在阅读代码的时候,就会发现是在视图层面和业务逻辑层频繁跳跃,你需要去不停的切换你思考的场景.这往往就会给前端开发对于整个业务的理解带来更大的成本;或者说在重构或者升级框架时,还依旧带着这种思路去做,那很大概率会重蹈覆辙.\n**其实vue和react的框架应用,它们更多的是站在我要去解决的是前端视图层面上的东西,解决基于dom元素如何在数据驱动模式下去进行自动更新.但是在react或者vue的生态里,它们没有提供一个完美的方案去解决业务要怎么结合框架去写好代码的问题**. 所以它们只是视图层面的框架,跟真正的软件架构体系还有一定的距离.\n**前端在业务领域内还没有形成一定的规范**\n如果你知道C#,你应该听过C#很好去做前后端同构,你可以理解为一份代码可以同时放在前后端运行.因为在开发的时候,一些特定的东西是按照特定的模式去相互共享的,包括一些业务上面的计算,比如前后端数值要保持一致、流程的判断.其实用的都是同一份代码,这样可以保证你在前端做的业务数据逻辑计算可以和后端保持一致.\n在传统或者说CS时期的软件架构体系下,工程师们要考虑业务对象的建模,业务流程控制,到了WEB应用的年代,前端的技术发展最早是不如后端技术的,比如说后端像JAVA,会有像spring这种大统一的主流框架,但前端是没有这种比较强统一的范式.所以虽然人们形容前端是百花齐放,但很多技术都是去探索解决眼前的问题,还没有更广阔的形成把握业务的范式.\n那如何解决这些问题呢?这时候可以用DDD架构的思路来解决.\n## 三. 什么是DDD架构\nDDD(Domain-Driven Design),domain这里是指领域的意思,是Eric Evans在2004年通过《Domain-Driven Design: Tackling Complexity in the Heart of Software》总结提出的一整套概念和方法论.以我个人薄弱的见解,DDD是从实际业务出发，站在解决领域问题的角度去思考和设计系统的方法论.它包含了两个方面的内容：\n* **沟通方法论**\n* **研发方法论**\n\n沟通方法论是讲DDD是站在研发人员的角度去告诉开发者怎么去和业务方和需求方进行沟通.比如像Retail团队,在当业务方(FPM)向我们提出一个需求时,其实背后是有一个需求方(BPM)去告诉FPM他们的诉求,FPM会和需求方去接触和了解这个诉求本质是因为什么东西变化而引起的,然后再根据自己的经验总结成能够呈现在我们系统上具体的一个功能.\n如果当开发者需要和需求方去沟通的时候,还是依旧站在技术的角度上(比如字段,事件)去进行,那这时候这种交流就会是很冲突的;或者说需求方不停和你说一些专业的业务词汇,如果没有很详细的解释这些词在当下的业务下的含义,作为开发者也是很难去领悟到需求方的动机.所以Eric在书里提供了一个方法论,我们可以基于一个**统一语言**去做沟通**.** 这个统一语言可以让技术人员和领域专家坐在一起构建出对应业务的**领域模型**，必须摒弃他们各自在自己工作范围内的狭义概念，大家找到一种相互都可以理解的概念表达方式，来最终确认各自提出的问题和回答对方都能准确理解.\n**我们可以使用*****UML(用图形的方式来描绘各种研发场景的对应的对象和关系)*****来作为统一语言进行构建领域模型.**\n## 四. 前端要关注的范畴，应该比后端还大一些\n作为一名业务系统的前端开发,需要去关注这几个方面的事情:\n* 业务模型(页面展示以及流程流转的条件控制等)\n* 数据服务\n* UI交互组件体系\n\n⠀前端开发注定不可能只关注业务模型，在前端，特别是web领域，除业务之外关注由后端吐出的数据和界面交互是一件必须的事。甚至有这样一种情况，产品文档中指出，“用户点击该按钮时，需要弹出二次确认窗口，点击确认后该签署流转为已完成”。在这个描述中，用户点击按钮弹出确认对话框，是否属于业务逻辑呢？从传统后端的角度，当然不属于，但是，如果去掉这个交互逻辑，能否完整表达这一业务过程呢？**这是一个值得思考的问题，前端如果要实施DDD，不可能照搬后端的实践。**前端无法脱离交互去谈业务模型,所以说,前端要关注的范畴,应该比后端还大一些。\n\n参考资料：\n[React语境下前端DDD的思考_唐霜的博客](https://www.tangshuang.net/8212.html)\n[前端数据治理之道](https://www.zhihu.com/column/c_1266667320073818112)\n","tags":["DDD"]},{"title":"Code Abstraction and Practical in DDD","url":"/2023/10/10/Code Abstraction and Practical in DDD/","content":"# **Code Abstraction and Practical in DDD**\n\n#个人/博客相关\n## Introduction\n* Background：In the complex business system of the supply chain, the front-end development work in the Retail team primarily involved creating single-page applications with **simple interactions but complex business logic.** Over time, as functionality accumulated, the team faced the following challenges:\n  * Dispersed logic, making it difficult to streamline\n  * Increasing complexity of business scenarios leading to **more quality issues**, even challenging test coverage.\n  * **Fear of making code changes** due to the risk of unintended consequences.\n  * **Difficulty migrating business components** from Element-UI to SSC-UI when switching component libraries, often requiring a complete rewrite\n+ Personal Thinking：\n  * Is solving the problem of data-driven interfaces enough, or should I consider preliminary ~[research and planning related to Domain-Driven Design \\(DDD\\)](https://confluence.shopee.io/pages/viewpage.action?pageId=914821098)\n  * In such a complex system, how can I effectively understand the business logic behind each technical detail to ensure **accurate business implementation**?\n## Research and Analysis \n+ What Kind of Code Design/Architecture Is More Suitable for the Current Business System\n+ **Mainstream Architecture Design for Frontend and Backend**\n  * Backend Architecture (java: j2ee, spring boot, spring cloud, SOA, microservices, DDD, DCI)\n  * Frontend Architecture (vue, react, vuex/redux, router, flux, micro frontends, BFF)⠀\nDDD (Domain-Driven Design) is an approach that starts from real business needs, focusing on solving domain problems when thinking and designing systems.\nFrom the practice of backend development based on DDD, the advantages include: i**t can help teams establish effective business communication standards and solidify the process of business logic.**\n**So, does frontend need DDD? Can frontend implement DDD?**\n## Do we need drive layering in Front-End?\nThe drawbacks of mainstream frontend frameworks' convenient development:\nMVVC application frameworks primarily address frontend view-level issues, solving how to automatically update based on DOM elements in a data-driven model.\n\nThis creates a problem: developers find it challenging to perceive when business data changes and what triggers those changes. When reading the code, you'll notice frequent jumps between the view layer and business logic layer, requiring constant context switching, **which adds more complexity to understanding the business logic for frontend development.**\n\n## How to Implement?\nAs a frontend developer in a business system, there are several aspects to focus on:\n* Business Models (including conditions for page display and workflow control)\n* Data Services\n* UI Interaction Component System\nThe scope of concern for frontend should be broader than that of the backend.\n**When it comes to implementing Domain-Driven Design (DDD) in the frontend, it cannot simply mimic backend practices. Frontend cannot separate itself from interactions to discuss business models.**\n\n## Frontend Layered Design\n![The Design of Business Logic Layer](/img/ddd/The Design of Business Logic Layer.png)\n### Directory Structure for Code\n* **view layout**\n**📁 components**\n**📁 pages**\n* **business logic layout**\n**📃 index: Entry File**\n**📁 constants**\n**📁 actions：Business Use Cases**\n**📁 schemas：Business Use Feilds**\n**📁 utils**\n\n* Data Access Layer (DAL): Interface for data storage, including various data sources such as local, code, and backend.\n* Business Logic Layer (BLL): Implements business models and interactions, delivering outputs based on specific scenarios.\n* Controller: Connects BLL and pages, configures access routes.\n* Pages: View Page, overseeing all internal components.\n* Common: Primarily includes utils and components without business logic\n### The Design of Business Logic Layer\n![bll主要代码骨架](/img/ddd/bll主要代码骨架.png)\n**Structure of bll：**\nStore： Business Data\nSchema： Business Field\neventTypes：Action Type\nactions： Business Action Logic\n**Method of bll：**\n$options: Basic Attrs passed from View\n$on: Register an event\n$emit: Trigger an event\nupdateSchema：Update Field\nupdateStore： Update Store data\n\n![bll主要代码骨架](/img/ddd/bll主要代码骨架.png)\n![具体业务场景处理](/img/ddd/具体业务场景处理.png)\n![在视图层调用bll](/img/ddd/在视图层调用bll.png)\n\n## Elaborating on Considerations - Implementation Effort\n* **The initial and learning costs are relatively high, and under the premise of frequent changes in the business architecture, the time cost of taking over does not proportionally align with the constraints imposed for benefits.**\n* The design of BLL (Business Logic Layer) primarily serves the development of complex business system types, while lightweight single-page solutions actually increase development costs.\n* DDD (Domain-Driven Design) is a methodology with the aim of achieving domain cohesion, and its core lies in how to better serve specific business scenarios.\n","tags":["DDD"]},{"title":"Vue插件--超长单和分级列表渲染优化","url":"/2021/03/26/Vue插件-超长单和分级列表渲染优化/","content":"\n### 前言\n\n组件仓库链接： [组件仓库](https://github.com/Appleking10/virtual-list)\n+ 组件效果图：\n![组件效果图](/img/3.png)\n\n+ 组件应用:\n\n<img src=\"/img/4.png\" alt=\"呈现效果\" width=\"40%\">\n<img src=\"/img/5.png\" alt=\"呈现效果\" width=\"40%\">\n\n\n\n因为工作需要，需要处理一个10w+数据量的transfer，所以将公司原先组件进行重构和升级。\n这篇教程主要内容为：\n1. 前提基础学习：GUI渲染时机、常见的超长列表渲染\n2. 超长单列表的渲染以及优化\n3. 再1的基础上，兼容分级列表\n4. 选择器transfer的构造\n5. 封装成插件，发布到npm上(to-do-list)\n\n### 1. 前提基础学习\n\n#### a. GUI渲染时机\n\n首先了解这个，要先了解js引擎是怎么工作的。\n\njs引擎是单核引擎，也就是说，js引擎只能开一条线程来处理进程。我们可以把这条线程，看成**执行栈**，里面会顺序推入要执行的代码块（比如函数），执行这块代码再去处理下块代码。\n\n那遇到异步任务怎么实现异步呢，关于这个可以参考下面流程图:\n\n<img src=\"/img/1.png\" alt=\"流程图\" width=\"100%\">\n\n①首先可以将一个js脚本看成一个宏任务，然后从上至下依次执行代码，遇到异步任务。②将异步任务分类，如果是微任务（如`Promsie`）就将微任务的回调函数放入微任务队列，如果是宏任务，就等宏任务成功或者时间到了（此时js引擎会将这个任务挂起，继续执行当前的同步代码），将成功回调放入宏任务队列。③当前同步代码全部执行完毕后，js引擎会去触发`EventLoop轮询处理线程`，先去看当前微任务队列是有有任务，若有任务，从队头任务开始执行，④等当前微任务队列清空后，**浏览器会进行一次GUI渲染**，⑤然后会去取一个宏任务放到执行栈，开始执行同步代码，遇到异步任务重复②\n\n以上便是EventLoop的原理。得出结论：**GUI渲染是在当前任务清空之后，执行下一个宏任务之前，进行的！**\n\n* 举例说明：要如何去测试函数和页面渲染性能呢\n  \n```html\n<div id=\"container\"></div>\n```\n\n```javascript\n    let total = 100000;\n    let timer = Date.now()\n    for(let i = 0;i < total; i++>){\n        let li = document.createElement('li')\n        li.innerHtml = i;\n        document.getElementById('container').appendChild(li)\n    }\n    console.log(Date.now() - timer) //计算执行时间\n\n```\n这段函数的本意是要计算total个li渲染到页面花了多少时间，但运行后会发现，输出的时间很短，但页面还未渲染完成100000个li。原因就是因为js引擎会将当前所有同步代码执行后，才会进行GUI渲染。对于js引擎来说，遍历100000次很轻松，但渲染100000个li却没有那么友好，因此会有一段白屏时间。\n\n那我们如何去计算函数从执行到页面渲染完毕的时间呢？可以在输出语句加上个定时器（宏任务），在执行定时器的之前，GUI渲染已经完成\n\n```javascript\n    let total = 100000;\n    let timer = Date.now()\n    for(let i = 0;i < total; i++>){\n        let li = document.createElement('li')\n        li.innerHtml = i;\n        document.getElementById('container').appendChild(li)\n    }\n    setTimeout(()=>{\n        console.log(Date.now() - timer)\n    },0) //计算执行+渲染时间\n```\n#### b. 如何处理超长列表渲染\n* 分片：根据数据大小，每次加载固定的数量。但有个明显缺点，加载越多，页面上累积的dom元素会很多，对性能不友好\n\n```javascript\nlet total = 10000;\nlet index = 0;\nlet id = 0;\nconst NUM = 20\nfunction load(){\n    index += NUM;\n    if(index < total){\n        //也可以用setTimeout，requestAnimationFrame可以配合浏览器刷新频率\n        requestAnimationFrame(()=>{\n            let fragment = document.createDocumentFragment();\n            //分片渲染\n            for(let i = 0;i<NUM;i++){ //ie浏览器，需要用到文档碎片\n                let li = document.createElement('li')\n                li.innerHtml = i;\n                fragment.appendChild(li)\n            }\n            document.getElementById('container').appendChild(li)\n            load()\n        })\n    }\n}\n```\n\n* 虚拟列表优化，只渲染当前的可视区（可以参考github上一个很成熟的vue插件：vue-virtual-scroll-list）\n\n**原理**：把列表当成一个数组，用`开始指针`和`结束指针`去决定可视区域的数据展示，当滚动条滑动的时候，去算滑过多少个了，指针也跟着移动位置，去指向应该展示的数据位置；如果列表每项不定高的话，还需要刷新每项的高度和滚动条的高度，这部分比较复杂。\n\n具体实现看第二部分\n\n### 2. 超长单列表的渲染以及优化\n思路大概是：\n  * 不管列表多长，我需要只显示可视区域有数据\n  * 告诉我的列表每一项多高(`itemH`)和多少条数据(`datas`) ==> 滚动条的高度\n  * 可设定显示多少条(`showNum`)\n  * 可设定是否不定高加载\n\n1. **列表结构设计**: \n   1. 主容器：可滚动的盒子，监听滚动事件。设置相对定位和`overflow:scroll`\n   2. 内层虚拟列表：设置相对定位，用于撑开主容器，用于展示数据\n\n```html\n<!-- 主容器 -->\n<div class=\"viewport\" ref=\"view\" @scroll=\"handleScroll\">\n    <!-- 虚拟列表，用padding-top来做偏移量 -->\n    <div \n        class=\"virtual-list\"  \n        ref=\"virtualList\" \n        :style=\"{paddingTop:`${offset}px`,lineHeight:`${itemH}px`}\"\n    >\n        <div v-for=\"(item,index) in virtualList\" class=\"item\" :key=\"item.key\" ref=\"item\">\n        <!-- 插槽：组件通过slot-scope=\"{item}\"接收 -->\n            <slot :item=\"item\"></slot>\n        </div>\n    </div>\n</div>\n<style lang='stylus' scoped>\n.viewport\n    width 500px\n    position relative\n    overflow-y scroll\n    .virtual-list\n        position relative\n        top 0\n        left 0\n        .item\n            box-sizing border-box\n</style>\n```\n2. **初始化:`mouted阶段`**\n   1. 主容器的高度 = itemH * showNum\n   2. 虚拟列表的真实高度 = itemH * datas.length\n   3. end = start + showNum\n   4. 虚拟列表数据：`virtualList = datas.slice(start,end)`,切割真实列表来形成\n   \n3. **滚动条监听**\n\n```javascript\nhandleScroll() {\n    let scrollTop = this.$refs.view.scrollTop;\n    //向下取整,滑过多少个了\n    this.start = Math.floor(scrollTop / this.itemH); \n    this.end = this.start + this.showNum;\n    this.offset = this.start * this.itemH; //虚拟列表视口偏移量     \n},\n```\n到这，一个最基础的虚拟列表加载就完成了。但还有很多细节要处理。\n\n4.  **预留占位渲染**\n如果用户滑的很快，还是会出现瞬间白屏的现象，因此需要在虚拟列表**前后**加上一品列表（数量也可以自定义）。可以通过将前后指针分别前后移动，增加虚拟列表渲染范围，同时需要将虚拟列表的视口取在中间段。\n\n<img src=\"/img/2.png\" alt=\"预留渲染图\" width=\"100%\">\n\n```javascript\n//在虚拟列表前后占一品位,返回位置\nprevCount() {\n    //若当前开始位置大于展示条数，说明需要占位\n    return Math.min(this.start, this.showNum);\n},\nnextCount() {\n    //若到达列表末尾，则返回剩下条数\n    return Math.min(this.datas.length - this.end, this.showNum);\n}\n\nvirtutalList =  this.datas.slice(\n                    this.start - this.prevCount, //向前一品\n                    this.end + this.nextCount) //向后一品\n                \n//如果有预留渲染，向上移动,可以借助上图理解\noffset = start * itemH - prevCount * itemH;\n\n```\n1. 优化滚动节流:借助lodash\n```javascript\nimport throttle from 'lodash/throttle'\n\ncreated(){\n    this.scrollFn = throttle(this.handleScroll,200,{leading；false})\n}\n```\n6. 不定高加载设计\n\n。。。 待补充\n\n### 3. 超长多级列表的渲染\n\n常见的超长列表渲染貌似都是考虑单列表（也就是一个列表），因为工作业务上的需求，我决定优化一下，设计成可以兼容二级列表。假设传入的是Map对象，即为二级列表\n\n1. **需要哪些变量来控制**\n* `foldFlag`: 数组，值为true和false。控制展开哪个二级列表，只能展开一个二级列表（数组值只有一个true，其它为false）\n* `unFoldIndex`: Number，保存当前展开的一级列表id,没有展开则为null\n\n2. **html结构上兼容**\n\n通过`v-if`和`v-else`来决定显示哪种列表\n\n```html\n<div class=\"viewport\" ref=\"view\" @scroll=\"scrolFn\" :style=\"{maxWidth:setMaxWidth}\">\n    <!-- 虚拟列表，用paddingTop来做偏移量 -->\n    <div class=\"virtual-list\" ref=\"virtualList\"\n        :style=\"{paddingTop:`${offset}px`,lineHeight:`${itemH}px`}\" >\n        <div class=\"item\"\n            v-for=\"(item,index) in virtualList\"\n            :key=\"item[0]+'-'+index\">\n            <!-- 如果传的是数组，那就是单级列表 -->\n            <div class=\"single-list\" v-if=\"Array.isArray(datas)\" :style=\"{height:`${itemH}px`}\">\n                <!-- 插槽：放置每一项列表，组件通过slot-scope=\"{item}\"接收 -->\n                <slot name=\"singleList\" :item=\"item\"></slot>\n            </div>\n            <!-- 传的是Map，多级列表 -->\n            <div class=\"main-list\" :style=\"{height:`${itemH}px`}\" @click=\"toggleFold(index,item)\"\n                v-else >\n                <!-- 下拉icon -->\n                <span style=\"display:inline-block;width:12px\">\n                    <span\n                        class=\"el-icon-caret-right\"\n                        :style=\"{transform: foldFlag[index]?'rotate(90deg)':'rotate(0deg)'}\"\n                        v-show=\"datas && datas.get(item[0])['children'].length>0\"\n                    ></span>\n                </span>\n                <!-- 放置一级菜单的slot -->\n                <slot name=\"main\" :main=\"item[0]\">{{item[0]}}</slot>\n            </div>\n            <!-- 展示的虚拟数据，若没有二级子级，便不显示 -->\n            <ul class=\"fold_tree\"\n                style=\"padding-left:30px;list-style: none;margin:0;\"\n                v-if=\"!Array.isArray(datas)&&foldFlag[index]&&item[1]['children'].length>0\"\n            >\n                <li style=\"white-space: nowrap;\"\n                    v-for=\"(child,idx) in item[1]['children'].slice()\"\n                    :key=\"road[label]+'-'+road[nodekey]\"\n                >\n                    <slot name=\"sub\" :sub=\"child\"></slot>\n                </li>\n            </ul>\n        </div>\n        <div v-if=\"datas.length == 0||datas.size==0\">暂无数据</div>\n    </div>\n</div>\n```\n\n3. **初始化阶段**\n   \n默认不展开二级菜单，则初始化只需展示所有的一级菜单即可\n* 滚动条长度 = `this.datas.size` * `this.itemH`\n* start = 0 \n* end = start + showNum > `this.datas.size` ? showNum :datas.size;\n* 虚拟列表数据：当前没有展开，便返回整个`datas`\n\n4. **展开二级列表设计**\n\n思路为：点击的时候去判断：以下展开情况，并计算各种情况的真实高度\n```javascript\ntoggleFold(index, item) {\n    let scrollH;\n    if (this.unFoldIndex === index) {\n        //若当前点击等于自己，则收起\n        this.$set(this.foldFlag, index, !this.foldFlag[index]);\n        this.unFoldIndex = null;\n        scrollH = this.itemH * (this.datas.size + 1);\n\n    } else if (this.unFoldIndex == null) {\n        //若是当前没有展开，则展开当前点击\n        this.$set(this.foldFlag, index, true);\n        //算上当前页面已有的一级列表高度\n        scrollH = this.itemH * (this.datas.size +  1 +\n                  this.datas.get(item[0])[\"children\"].length);\n        this.unFoldIndex = index;\n    } else {\n        //若点击时已有别的列表展开，便收起其它列表，展开当前列表\n        this.$set(this.foldFlag, this.unFoldIndex, false);\n        this.$set(this.foldFlag, index, true);\n        scrollH = this.itemH *  (this.datas.size + 1 +\n                  this.datas.get(item[0])[\"children\"].length);\n        this.unFoldIndex = index;\n    }\n    //不管展开或者收起，都将指针初始化\n    this.start = 0; //控制当前列表的指针\n    this.end = this.start + this.showNum;\n    this.$refs.virtualList.style.height = scrollH + \"px\";\n}\n```\n5. **虚拟列表的截取**\n\n思路：先判断有无展开，无展开便展示一级菜单；有展开便去获取当前展开的一级菜单的id和二级项，然后在二级项去截取。向后占位也要判断是否有展开\n\n```javascript\nvirtualList() {\n    if (this.datas) {\n        if (Array.isArray(this.datas)) {\n            return this.datas.slice(\n                this.start - this.prevCount,\n                this.end + this.nextCount\n            );\n        } else {\n            if (this.unFoldIndex === null) {\n                //若当前没有展开\n                return this.datas;\n            } else {\n                //若当前展开了，找到展开的一级菜单，切割当前列表\n                //深拷贝对性能不太好\n                // let data = _.cloneDeep(this.datas);\n                let data = new Map();\n                //优化后写法,截取当前展开的二级菜单数组\n                this.datas.forEach((road, name) => {\n                    let obj = { children: [], id: road.id };\n                    obj[this.label] = road[this.label];\n                    obj[this.nodekey] = road[this.nodekey];\n                    data.set(name, obj);\n                });\n                // 返回截取后的Map\n                let key = [...this.datas][this.unFoldIndex][0];\n                let roadArr = [...this.datas][this.unFoldIndex][1][\"children\"].slice(\n                    this.start - this.prevCount,\n                    this.end + this.nextCount\n                );\n                //替换展现的二级数组\n                let newObj = data.get(key);\n                newObj[\"children\"] = roadArr;\n                data.set(key, newObj);\n                return data;\n            }\n        }\n    }\n},\n//向后占位也要判断是否有展开\nnextCount() {\n    //若到达列表末尾，则返回剩下条数\n    if (Array.isArray(this.datas)) {\n        return Math.min(this.datas.length - this.end, this.showNum);\n    } else {\n        //若当前没有展开\n        if (this.unFoldIndex === null) {\n            return Math.min(this.datas.size - this.end, this.showNum);\n        } else {\n            //若展开，找到当前展开二级菜单所有数据\n            let data = [...this.datas][this.unFoldIndex][1];\n            return Math.min(data.length - this.end, this.showNum);\n        }\n    }\n}\n```\n6. **滚动监听**\n\n思路：如果有展开，并且滚动距离已经超过当前要展开的一级列表上面菜单的总高度，便去更改`start`，`end`，`offset`\n\n```javascript\nhandleScroll() {\n    let scrollTop = this.$refs.view.scrollTop;\n    if (Array.isArray(this.datas)) {\n        this.start = Math.floor(scrollTop / this.itemH); //向下取整,滑过多少个了\n        this.end = this.start + this.showNum;\n        //如果有预留渲染，向上移动\n        this.offset = this.start * this.itemH - this.prevCount * this.itemH;\n    } else {\n        //如果有展开，才会去改变展示数据\n        if (this.unFoldIndex != null) {\n            //如果滑动距离超过展开上面一级菜单的长度\n            if (scrollTop > (this.unFoldIndex + 2) * this.itemH) {\n                //截取的开始指针= 滑过多少个\n                this.start = Math.floor(\n                    (scrollTop - (this.unFoldIndex + 1) * this.itemH) / this.itemH\n                );\n                //虚拟列表的偏移量，应该向下顶多少\n                this.offset = this.start * this.itemH - this.prevCount * this.itemH;\n            } else {\n                this.start = 0;\n                this.offset = 0;\n            }\n            this.end = this.start + this.showNum;\n        }\n    }\n},\n```\n\n7. **勾选功能的设计**\n\n引入勾选功能，可以在加上一个是否开启可以勾选的变量。思路是：用一个集合`new Set()`来保存已选中的item,每条的勾选框的`v-model`用是否存在勾选集合中来显示。\n勾选分为三种情况：全选，一级全选，二级单条勾选，因此在勾选的时候要分情况考虑\n\n* 全选：判断当前是否勾选了->若勾选了，取消勾选，并`set.clear()`,清空集合；->若没有勾选，全选，并把所有一级菜单和二级菜单全部`add`\n* 一级全选：判断当前是否勾选了-> 若勾选了，取消当前一级勾选和全选和当前子集 -> 若没有勾选，勾选一级菜单和当前子集，判断当前一级菜单是否全部勾选了（`arr.every(()=>{})`）\n* 二级单条勾选：判断当前是否勾选了 -> 若勾选了，取消勾选自己和当前所在一级勾选和全选 -> 若没有勾选，勾选自己，并且判断当前所在一级菜单是否全选了和是否全选了\n\n8. **过滤搜索功能的设计**\n\n思路是先给数据打上拼音标识，比如网格001（wangge001），国道s108（guodaos108），然后再输入的时候，将输入值转成拼音，在所有数据的拼音标识遍历，若包含在里面便返回\n\n```javascript\n//给标签加拼音标识\naddPYtag() {\n    //单极列表的情况\n    if (Array.isArray(this.datas)) {\n        //先加载再去执行\n        setTimeout(() => {\n            this.datas = this.datas.map(\n                e => {\n                    e[\"py\"] = this.setPinyinConvert(e[this.label]);\n                    return e;\n                }\n            );\n        }, 0);\n    } else {\n        setTimeout(() => {\n            //遍历所有数据\n            this.datas.forEach((val, key) => {\n                if (val[\"children\"].length > 0) {\n                    //若有子集\n                    val[\"children\"] = val[\"children\"].map(e => {\n                        e[\"py\"] = this.Pinyin.convertPinyin(e[this.label]);\n                        return e;\n                    });\n                    this.datas.set(key, val);\n                } else {\n                    val[\"py\"] = this.Pinyin.convertPinyin(val[this.label]);\n                    this.datas.set(key, val);\n                }\n            });\n        }, 0);\n    }\n}\n\n//模糊搜索:\n// @searchVal：搜索值\n// @resultMapName：要保存的返回结果的变量名\n// @dataName：已有拼音标识的原始数据变量名\nquerySearch(searchVal, resultMapName, dataName) {\n    let results = [];\n    //如果有搜索词\n    if (searchVal) {\n        // 将搜索词转成拼音\n        let py = this.Pinyin.convertPinyin(searchVal.toLowerCase());\n        if (!Array.isArray(this[dataName])) {\n            //在py字段搜索这个拼音，符合返回\n            this[dataName].forEach((val, key) => {\n                if (val[\"children\"].length > 0) {\n                    results = results.concat(val[\"children\"].filter(e => {\n                        e[\"parentKey\"] = key;\n                        return (e[\"py\"].toLowerCase().indexOf(py) > -1);\n                    }));\n                } else {\n                    if (val[\"py\"].toLowerCase().indexOf(py) > -1) {\n                        results.push(val);\n                    }\n                }\n            });\n        } else {\n            this[dataName].forEach(item => {\n                if (item[\"py\"].toLowerCase().indexOf(py) > -1) {\n                    results.push(item);\n                }\n            });\n        }\n    } else {\n        results = this[dataName];\n    }\n    this[resultMapName] = results;\n}\n```","tags":["Vue实战","技能篇"]},{"title":"该抛弃无效的重复练习了","url":"/2021/02/26/该抛弃无效的重复练习了/","content":"## 该抛弃无效的重复练习了\n\n**——《刻意练习》读后感**\n\n不知道大家是否听过一万小时理论，该理论认为不论你的天赋、出身如何，只要坚持练习一万小时，就机会成为领域内专家。但如果真的是这样的话，那我们从小学开始到现在，一直在学习英语，时间也不短了，我们拥有了很流利的英语口语能力了吗？\n\n单一重复的练习并非都是有效。重复练习的根本问题就是在于我们面对大量的工作任务没有自己想要得到的一个目标方向，而有目标练习的核心就是具有定义明确的特定目标。有时我们拼尽全力却依然原地踏步，这大概就是无效的重复练习。\n\n这本书就很明确的指出了一万小时定律存在的问题，从而引出了这三个问题：\n\n**1. 天才真的存在吗？**\n\n**2. 什么是刻意练习？**\n\n**3. 如何从新手成为大师？**\n\n### 1.  **天才真的存在吗？**\n\n作者研究了大量天才后发现，人们之所以对所谓天才有‘他们生来就具有某种特殊的能力，不用特意训练仍然可以变成杰出人物的印象，经过训练，可以获得和天才一样的表现。这对传统认知的产生颠覆：**通过高强度训练，能够改造身体和大脑，产生像天赋一般的奇迹能力，从而铸就天才**。\n\n所以天才也不是天生的，天才是训练的产物。\n\n### 2.  **刻意练习是什么**？\n\n作者在书中讲到，卓越的专家之所以卓越，就在于他们能够调用更大容量的工作记忆。而这种记忆能力，是可以通过刻意练习得来的。那什么是刻意练习？与一般的学习路径有啥区别呢？\n\n总结如下**：**\n\n1.  **学会找到一套行之有效的训练方法**\n\n    1.  一旦已经学会了某个东西，就不应该继续在上面花时间，应该**立即转入**下一个难度，长期使用这种方法训练必然事半功倍。\n\n    2.  需要**持续获得有效的反馈，不论你在努力做什么事情，都需要反馈来准确辨别你在哪些方面还有不足，以及怎么会存在这些不足。如果没有反馈，你不可能搞清楚你在哪些方面还需提高，或者你现在离实现你的目标有多远。**\n\n    3.  **精神高度集中，训练中必须专注，不能心不在焉。我们常常只是在做，而并没有认真地去思考，就像福尔摩斯说的，你只是在看，而并没有观察。**\n\n### 3.  **如何从新手成为大师？**\n\n3.  **产生兴趣**。无论你是受他人影响，还是自己探索世界的时候产生好奇心，或者是受到其他人的鼓励，你可能就会对某件事或者是某个领域产生兴趣，这是你充满激情充满热情的第1步。\n\n4.  **变得认真**。当你感兴趣了，那你就要开始正式的上课，训练可以练习了，在这个阶段，身边人的支持和鼓励其实是很重要的。并且自己在通过不断的练习，看到自己的练习成果受到尊重和认可的时候，当然也会让从而获得继续练习继续努力的动机。\n\n5.  **全力投入**。这个阶段要付出巨大的投入，才能成为自己领域或行业中最杰出的人物。学生常常会寻找最好的导师或学校来指导自己的练习，甚至需要在全国范围内寻找。\n\n6.  **开拓创新**。这是杰出成就的第四个阶段，在这个阶段，有些人超越了他们的领域和行业中现有的知识，做出了独特的创造性贡献。\n\n最后想谈一谈我读完这本书后的**感想**。\n\n第一，什么时候开始都不晚。对于这本书有点相见恨晚的感觉，学生时代老师“努力学习”的说教显得十分空洞，而通过《刻意练习》中大量的案例和数据让我们看到了“刻意练习”的力量，这种说教似乎更容易让人信服。可能多少会有些遗憾，比如要是我高中时代采用这种方法，我的成绩会提高多少呢，但这些已然是沉没成本，我们更多的应该想想以后工作生活的应用，**什么时候开始都不晚，晚的是你不开始。**\n\n第二，在工作中，我们应该运用刻意练习。特别是在接触新的技术和项目，需要学习新的工作技能，如何快速掌握，不断提高呢？刻意练习是个很好的方法，在工作中，学习可以分为两个方面，一部分是**显性知识的学习**，这部分我们可以直接通过不断练习和接受反馈，来使自己快速提高，比如review代码、小组周会总结、PPT制作等等；另一方面是**隐性知识**，比如工作方法，沟通技巧，这部分我们要尽量运用刻意练习的原则，找到部门内该方面优秀的老师，观察他与其他人的处理方式的不同，并在自己从事相关工作时，尽可能让老师给你指导、反馈。\n","tags":["读后感"]},{"title":"前端核心基础知识总结","url":"/2021/01/28/前端核心基础知识总结/","content":"\n### 一. HTML标签知多少？\n\n#### 1. meta标签：自动刷新/跳转\n\n```html\n<meta http-equiv=\"Refresh\" content=\"5; URL=page2.html\">\n<!-- 上面的代码会在 5s 之后自动跳转到同域下的 page2.html 页面。 -->\n\n<meta http-equiv=\"Refresh\" content=\"60\">\n<!-- 间隔60s刷新一次页面 -->\n```\n#### 2. 运用title标签实现消息提醒\n\n消息提醒功能实现则比较困难，HTML5 标准发布之前，浏览器没有开放图标闪烁、弹出系统消息之类的接口，只能借助一些 Hack 的手段，比如修改 title 标签来达到类似的效果（HTML5 下可使用`Web Notifications API`弹出系统消息）。\n\n```javascript\nlet msgNum = 1 // 消息条数\nlet cnt = 0 // 计数器\nconst inerval = setInterval(() => {\n  cnt = (cnt + 1) % 2\n  if(msgNum===0) {\n    // 通过DOM修改title\n    document.title += `聊天页面`\n    clearInterval(interval)\n    return\n  }\n  const prefix = cnt % 2 ? `新消息(${msgNum})` : ''\n  document.title = `${prefix}聊天页面`\n}, 1000)\n```\n关于`Web Notifications API`的基本方法可以在[Web Notifications API MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/notification/Using_Web_Notifications)上浏览。\n\n> PS：消息通知只有通过Web服务访问该页面时才会生效，如果直接双击打开本地文件，是没有任何效果的。也就是说你的文件需要使用服务器的形式打开，而不是直接使用浏览器打开本地文件。\n\n#### 3. 通过标签实现的性能优化\n\n性能问题无外乎两方面原因：渲染速度慢、请求时间长。性能优化虽然涉及很多复杂的原因和解决方案，但其实只要通过合理地使用标签，就可以在一定程度上提升渲染速度以及减少请求时间。\n\na. **script 标签：调整加载顺序提升渲染速度**\n\n由于浏览器的底层运行机制，渲染引擎在`解析HTML`时，若遇到`script标签`引用文件，则会暂停解析过程，同时通知网络线程加载文件，文件加载后会切换至`JavaScript引擎`来执行对应代码，代码执行完成之后切换至渲染引擎继续渲染页面。\n\n在这一过程中可以看到，页面渲染时间 = 请求文件 + 执行文件的时间，但页面的首次渲染可能并不依赖这些文件，这些请求和执行文件的动作反而延长了用户看到页面的时间，从而降低了用户体验（比如白屏）。\n为了减少这些时间损耗，可以借助 script 标签的 3 个属性来实现。\n* async 属性。立即请求文件，但不阻塞渲染引擎，而是文件加载完毕后阻塞渲染引擎并立即执行文件内容。\n* defer 属性。立即请求文件，但不阻塞渲染引擎，等到解析完 HTML 之后再执行文件内容。\n* HTML5 标准 type 属性，对应值为“module”。让浏览器按照 ECMA Script 6 标准将文件当作模块进行解析，默认阻塞效果同 defer，也可以配合 async 在请求完成后立即执行。\n\n>PS: 除此之外还应当注意，当渲染引擎解析 HTML 遇到 script 标签引入文件时，会立即进行一次渲染。所以这也就是为什么构建工具会把编译好的引用 JavaScript 代码的 script 标签放入到 body 标签底部，因为当渲染引擎执行到 body 底部时会先将已解析的内容渲染出来，然后再去请求相应的 JavaScript 文件。如果是内联脚本（即不通过 src 属性引用外部脚本文件直接在 HTML 编写 JavaScript 代码的形式），渲染引擎则不会渲染。\n\nb. **link 标签：通过预处理提升渲染速度**\n\n* dns-prefetch。当 link 标签的 rel 属性值为“dns-prefetch”时，浏览器会对某个域名预先进行 DNS 解析并缓存。这样，当浏览器在请求同域名资源的时候，能省去从域名查询 IP 的过程，从而减少时间损耗。\n* preconnect。让浏览器在一个 HTTP 请求正式发给服务器前预先执行一些操作，这包括 DNS 解析、TLS 协商、TCP 握手，通过消除往返延迟来为用户节省时间。\n* prefetch/preload。两个值都是让浏览器预先下载并缓存某个资源，但不同的是，prefetch 可能会在浏览器忙时被忽略，而 preload 则是一定会被预先下载。\n* prerender。浏览器不仅会加载资源，还会解析执行页面，进行预渲染\n\n以上特性也反映出了浏览器获取资源文件的流程：\n\n浏览器处理资源引用 -> DNS解析 -> 建立TCP连接 -> 获取HTTP请求内容 -> 渲染页面\n\n#### 4. 搜索优化\n\n* meta标签：提取关键信息\n\n为了让搜索引擎更好的识别页面，最好是给网站添加合适的搜索关键词\n\n```html\n<meta content=\"搜索关键词，用逗号隔开\" name=\"keywords\">\n```\n在实际工作中，推荐使用一些关键字工具来挑选，比如 、[站长工具](http://tool.chinaz.com/)、Google Trends。\n\n* link标签：减少重复\n有时候为了用户访问方便或者出于历史原因，对于同一个页面会有多个网址，又或者存在某些重定向页面，比如：\n    https://xx.com/a.html\n    https://xx.com/detail?id=\"abcd\"\n\n那么在这些页面中可以这样设置：\n```html\n<link href=\"https://xx.com/a.html\" rel=\"canonical\">\n```\n这样可以让搜索引擎避免花费时间抓取重复网页。不过需要注意的是，它还有个限制条件，那就是指向的网站不允许跨域。\n\n当然，要合并网址还有其他的方式，比如使用站点地图。\n\n### 二. 关于DOM元素\n\n#### 1. DOM\n大部分前端功能需要借助DOM来实现，比如监听点击事件，动态渲染列表，懒加载脚本或样式。根据DOM V3标准，会发现包含多个内容，归纳起来由3大部分的内容组成：\n* DOM 节点\n* DOM 事件\n* 选择区域\n\na. **DOM 节点**\n对于 DOM 节点，需与另外两个概念标签和元素进行区分：\n\n`标签`是 HTML 的基本单位，比如 p、div、input；\n`节点`是 DOM 树的基本单位，有多种类型，比如注释节点、文本节点；\n`元素`是节点中的一种，与 HTML 标签相对应，比如 p 标签会对应 p 元素。\n```\n<!--\n    \"p\" 是标签， \n    生成 DOM 树的时候会产生两个节点，一个是元素节点 p，另一个是字符串为\"苹果苹果\"的文本节点。\n-->\n<p>苹果苹果</p>\n```\nb. **DOM 操作**\n\nDOM频繁的操作其实对浏览器的性能来说很不友好，有很大的性能损耗问题。这其中的原因，就要先了解一下**浏览器的工作机制**。\n\n* 线程切换\n浏览器包含`渲染引擎`（也称浏览器内核）和 `JavaScript引擎`，它们都是单线程运行。单线程的优势是开发方便，避免多线程下的死锁、竞争等问题，劣势是失去了并发能力。\n\n浏览器为了避免两个引擎同时修改页面而造成渲染结果不一致的情况，增加了另外一个机制，这两个引擎具有**互斥性**，也就是说在某个时刻只有一个引擎在运行，另一个引擎会被阻塞。操作系统在进行线程切换的时候需要保存上一个线程执行时的状态信息并读取下一个线程的状态信息，俗称上下文切换。而这个操作相对而言是比较耗时的。\n\n每次 DOM 操作就会引发线程的上下文切换——从 JavaScript引擎切换到渲染引擎执行对应操作，然后再切换回 JavaScript 引擎继续执行，这就带来了**性能损耗**。单次切换消耗的时间是非常少的，但是如果频繁的大量切换，那么就会产生性能问题。\n\n```javascript\n// 测试次数：一百万次\nconst times = 1000000\n// 缓存body元素\nlet body = document.body\n// 循环赋值对象作为对照参考\nfor(let i=0;i<times;i++) {\n  let tmp = body\n}\nconsole.timeEnd('object')// object: 1.77197265625ms\n\n// 循环读取body元素引发线程切换\nfor(let i=0;i<times;i++) {\n  let tmp = document.body\n}\nconsole.timeEnd('dom')// dom: 18.302001953125ms\n```\n    \n* 重排和重绘\n\n另一个更加耗时的因素是元素及样式变化引起的再次渲染，在渲染过程中最耗时的两个步骤为**重排**（Reflow）与**重绘**（Repaint）。\n\n浏览器在渲染页面时会将 `HTML` 和 `CSS` 分别解析成 `DOM 树`和 `CSSOM 树`，然后合并进行排布，再绘制成我们可见的页面。如果在操作 DOM 时涉及到元素、样式的修改，就会引起渲染引擎重新计算样式生成 CSSOM 树，同时还有可能触发对元素的**重排**和**重绘**。\n\n* 如何高效操作DOM\n  * 在循环外操作元素\n  * 批量操作元素\n比如说要创建 1 万个 div 元素，在循环中直接创建再添加到父元素上耗时会非常多。如果采用字符串拼接的形式，先将 1 万个 div 元素的 html 字符串拼接成一个完整字符串，然后赋值给 body 元素的 innerHTML 属性就可以明显减少耗时。\n  * 缓存元素集合\n比如将通过选择器函数获取到的 DOM 元素赋值给变量，之后通过变量操作而不是再次使用选择器函数来获取。\n假设我们现在要将上面代码所创建的 1 万个 div 元素的文本内容进行修改。每次重复使用获取选择器函数来获取元素。\n```javascript\nfor (let i = 0; i < document.querySelectorAll('div').length; i++) {\n  document.querySelectorAll(`div`)[i].innerText = i\n}\n//21965ms\n```\n如果能够将元素集合赋值给 JavaScript 变量，每次通过变量去修改元素，那么性能将会得到不小的提升。\n```javascript\nconst divs = document.querySelectorAll('div')\nfor (let i = 0; i < divs.length; i++) {\n  divs[i].innerText = i\n}\n//211ms\n```\nc. **总结**\n\n* 尽量不要使用复杂的匹配规则和复杂的样式，从而减少渲染引擎计算样式规则生成 CSSOM 树的时间；\n* 尽量减少重排和重绘影响的区域；\n* 使用 CSS3 特性来实现动画效果。\n\n#### 2. DOM事件\n\na. **防抖**\n对于一些连续触发的事件，有时候并不需要那么频繁去触发，需要添加一个\"防抖\"功能，为函数的执行设置一个合理的时间间隔，避免事件在时间间隔内频繁触发，同时又保证事件的正常使用功能。\n要实现防抖，自然而然就是想到使用定时器来延迟执行。比如：输入搜索的功能\n```javascript\nconst ipt = document.querySelector('input')\nlet timeout = null; //存储计时器\nipt.addEventListener('input', e => {\n  if(timeout) {\n    clearTimeout(timeout)\n    timeout = null\n  }\n  timeout = setTimeout(() => {\n    search(e.target.value).then(resp => {\n      // 搜索回调\n    }, e => {\n      // ...\n    })  \n  }, 500)  \n})\n```\n问题确实是解决了，但这并不是最优答案，或者说我们需对这个防抖操作进行一些“优化”。\n\n试想一下，如果另一个搜索框也需要添加防抖，是不是也要把 timeout 相关的代码再编写一次？而其实这个操作是完全可以抽取成公共函数的。\n\n在抽取成公共函数的同时，还需要考虑更复杂的情况：\n\n* 参数和返回值如何传递？\n* 防抖化之后的函数是否可以立即执行？\n* 防抖化的函数是否可以手动取消？\n\n具体代码如下所示，首先将原函数作为参数传入 `debounce()` 函数中，同时指定延迟等待时间，返回一个新的函数，这个函数包含 `cancel` 属性，用来取消原函数执行。`flush` 属性用来立即调用原函数，同时将原函数的执行结果以 `Promise` 的形式返回。\n\n```javascript\n// 封装API\nconst debounce = (func, wait = 0) => {\n  let timeout = null\n  let args\n  function debounced(...arg) {\n    args = arg\n    if(timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n    // 以Promise的形式返回函数执行结果\n    return new Promise((res, rej) => {\n      timeout = setTimeout(async () => {\n        try {\n          const result = await func.apply(this, args)\n          res(result)\n        } catch(e) {\n          rej(e)\n        }\n      }, wait)\n    })\n  }\n  // 允许取消\n  function cancel() {\n    clearTimeout(timeout)\n    timeout = null\n  }\n  // 允许立即执行\n  function flush() {\n    cancel()\n    return func.apply(this, args)\n  }\n  debounced.cancel = cancel\n  debounced.flush = flush\n  return debounced\n}\n```\n> 也可以参考lodsh的debounce()函数\n\nb. **节流**\n一般监听滚动事件的时候需要考虑节流，我们可以设置在指定一段时间内只调用一次函数，从而降低函数调用频率，这种方式我们称之为“节流”。\n\n实现节流函数的过程和防抖函数有些类似，只是对于节流函数而言，有两种执行方式，在调用函数时执行最先一次调用还是最近一次调用，所以需要设置时间戳加以判断。我们可以基于 debounce() 函数加以修改。\n\n```javascript\nconst throttle = (func, wait = 0, execFirstCall) => {\n  let timeout = null\n  let args\n  let firstCallTimestamp\n\n  function throttled(...arg) {\n    if (!firstCallTimestamp) firstCallTimestamp = new Date().getTime()\n    if (!execFirstCall || !args) {\n      console.log('set args:', arg)\n      args = arg\n    }\n    if (timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n    // 以Promise的形式返回函数执行结果\n    return new Promise(async(res, rej) => {\n      if (new Date().getTime() - firstCallTimestamp >= wait) {\n        try {\n          const result = await func.apply(this, args)\n          res(result)\n        } catch (e) {\n          rej(e)\n        } finally {\n          cancel()\n        }\n      } else {\n        timeout = setTimeout(async () => {\n          try {\n            const result = await func.apply(this, args)\n            res(result)\n          } catch (e) {\n            rej(e)\n          } finally {\n            cancel()\n          }\n        }, firstCallTimestamp + wait - new Date().getTime())\n      }\n    })\n  }\n  // 允许取消\n  function cancel() {\n    clearTimeout(timeout)\n    args = null\n    timeout = null\n    firstCallTimestamp = null\n  }\n  // 允许立即执行\n  function flush() {\n    cancel()\n    return func.apply(this, args)\n  }\n  throttled.cancel = cancel\n  throttled.flush = flush\n  return throttle\n} \n```\n节流与防抖都是通过延迟执行，减少调用次数，来优化频繁调用函数时的性能。不同的是，对于一段时间内的频繁调用，防抖是延迟执行后一次调用，节流是延迟定时多次调用。\n\nc. **代理**\n\n下面的 HTML 代码是一个简单的无序列表，现在希望点击每个项目的时候调用 getInfo() 函数，当点击“编辑”时，调用一个 edit() 函数，当点击“删除”时，调用一个 del() 函数。\n\n```html\n<ul class=\"list\">\n  <li class=\"item\" id=\"item1\">项目1<span class=\"edit\">编辑</span><span class=\"delete\">删除</span></li>\n  <li class=\"item\" id=\"item2\">项目2<span class=\"edit\">编辑</span><span class=\"delete\" >删除</span></li>\n  <li class=\"item\" id=\"item3\">项目3<span class=\"edit\">编辑</span><span class=\"delete\">删除</span></li>\n  ...\n</ul>\n```\n要实现这个功能并不难，只需要对列表中每一项，分别监听 3 个元素的 click 事件即可。\n\n但如果数据量一旦增大，事件绑定占用的内存以及执行时间将会成线性增加，而其实这些事件监听函数逻辑一致，只是参数不同而已。此时我们可以以事件代理或事件委托来进行优化。\n\n* DOM事件触发流程（三个阶段）\n  * **捕获**：事件对象 Window 传播到目标的父对象,如图<span style=\"color:red;\">红色线</span>\n  * **目标**：事件对象到达事件对象的事件目标，如图<span style=\"color:blue;\">蓝色过程</span>\n  * **冒泡**：事件对象从目标的父节点开始传播到 Window,如图<span style=\"color:green;\">绿色线</span>\n\n![冒泡流程图](https://wx2.sbimg.cn/2020/06/09/mapao.png)\n\n**我们上面提到的给元素的事件行为绑定方法都是在当前元素事件行为的冒泡阶段(或者目标阶段)执行的。**\n\n```html\n<body>\n  <button>click</button>\n</body>\n<script>\ndocument.querySelector('button').addEventListener('click', function () {\n  console.log('bubble')\n})\ndocument.querySelector('button').addEventListener('click', function () {\n  console.log('capture')\n}, true)\n// 执行结果\n// buble\n// capture\n</script>\n```\n例如，在上面面的代码中，虽然我们第二次进行事件监听时设置为捕获阶段，但点击事件时仍会按照监听顺序进行执行。（若是调换两个监听函数的顺序，则输出相反的结果）\n\n我们再回到事件代理，事件代理的实现原理就是利用上述 DOM 事件的触发流程来对一类事件进行统一处理。比如对于上面的列表，我们在 ul 元素上绑定事件统一处理，通过得到的事件对象来获取参数，调用对应的函数。\n\n```javascript\nconst ul = document.querySelector('.list')\nul.addEventListener('click', e => {\n  const t = e.target || e.srcElement\n  if (t.classList.contains('item')) {\n    getInfo(t.id)\n  } else {\n    id = t.parentElement.id\n    if (t.classList.contains('edit')) {\n      edit(id)\n    } else if (t.classList.contains('delete')) {\n      del(id)\n    }\n  }\n})\n```\n虽然这里我们选择了默认在冒泡阶段监听事件，但和捕获阶段监听并没有区别。\n对于其他情况还需要具体情况具体细分析，比如有些列表项目需要在目标阶段进行一些预处理操作，那么可以选择冒泡阶段进行事件代理。\n\n> **事件监听方式的区别**\n>```javascript\n// 方式1\n<input type=\"text\" onclick=\"click()\"/>\n// 方式2\ndocument.querySelector('input').onClick = function(e) {// ...}\n// 方式3\ndocument.querySelector('input').addEventListener('click', function(e) {//...})\n>```\n> 方式 1 和方式 2 同属于 DOM0 标准，通过这种方式进行事件监会**覆盖**之前的事件监听函数。\n> 方式 3 属于 DOM2 标准，推荐使用这种方式。同一元素上的事件监听函数**互不影响**，而且可以独立取消，调用顺序和监听顺序一致。\n\n#### 3.浏览器渲染页面的过程:字节 → 字符 → 令牌 → 树 → 页面\n假如我们在浏览器中输入了一个网址，得到了下面的 html 文件，渲染引擎是怎样通过解析代码生成页面的呢？\n```html\n<html>\n  <head>\n  </head>\n  <body>\n    文本\n  </body>\n</html>\n```\n1.字符流解码\n对于上面的代码，我们看到的是它的字符形式。而浏览器通过 HTTP 协议接收到的文档内容是`字节数据`，。当浏览器得到字节数据后，通过“编码嗅探算法”来确定字符编码，然后根据字符编码将字节流数据进行`解码`，也就是我们编写的代码。\n```\n69 6f 6e 23 2b 65  |<html> <head></head>...\n0a 43 52 45 4a 66  |\n6c 37 77 41 3d 0a  |\n```\n这个把字节数据解码成字符数据的过程称之为“字节流解码”。\n\n2.输入流预处理\n通过上一步解码得到的字符流数据在进入解析环节之前还需要进行一些预处理操作。比如将换行符转换成统一的格式，最终生成规范化的字符流数据，这个把字符数据进行统一格式化的过程称之为“输入流预处理”。\n\n3.令牌化\n经过前两步的数据解码和预处理，下面就要进入重要的解析步骤了。\n\n解析包含两步，第一步是将`字符数据`转化成`令牌`（Token），第二步是解析 `HTML` 生成`DOM 树`。先来说说令牌化，其过程是使用了一种类似`状态机`的算法，即每次接收一个或多个输入流中的字符；然后根据当前状态和这些字符来更新下一个状态，也就是说在不同的状态下接收同样的字符数据可能会产生不同的结果，比如当接收到`body`字符串时，在标签打开状态会解析成标签，在标签关闭状态则会解析成文本节点。\n最后生成的令牌结构类似如下:\n```\n开始标签:html\n  开始标签:head\n  结束标签:head\n  开始标签:body\n    字符串:文本\n  结束标签:body\n结束标签:html\n```\n4.构建DOM树\n浏览器在创建`解析器`的同时会创建一个 `Document 对象`。在树构建阶段，`Document` 会作为**根节点**被不断地修改和扩充。标记步骤产生的令牌会被送到`树构建器`进行处理。HTML 5 标准中定义了每类令牌对应的 DOM 元素，当树构建器接收到某个令牌时就会创建该令牌对应的 DOM 元素并将该元素插入到 DOM 树中。\n为了纠正元素标签嵌套错位的问题和处理未关闭的元素标签，树构建器创建的新 DOM 元素还会被插入到一个开放元素栈中。\n最终生成下面的 DOM 树结构：\n```\n      Document\n      /       \\\nDocumentType   HTMLHtmlElement\n                  /         \\\n    HTMLHeadElement         HTMLBodyElement\n                                  |\n                                TextNode\n```\n5.构建渲染树\n有了 DOM 树和 CSSOM 树之后，渲染引擎就可以开始生成页面了。\n`DOM 树`包含的结构内容与 `CSSOM 树`包含的样式规则都是独立的，为了更方便渲染，先需要将它们合并成一棵渲染树。\n这个过程会从 DOM 树的根节点开始遍历，然后在 CSSOM 树上找到每个节点对应的样式。\n遍历过程中会自动忽略那些不需要渲染的节点（比如脚本标记、元标记等）以及不可见的节点（比如设置了“display:none”样式）。同时也会将一些需要显示的伪类元素加到渲染树中。\n对于上面的 HTML 和 CSS 代码，最终生成的渲染树就只有一个 body 节点，样式为 font-size:12px(浏览器默认css属性)。\n\n6.布局\n生成了渲染树之后，就可以进入布局阶段了，布局就是计算元素的大小及位置。\n计算元素布局是一个比较复杂的操作，因为需要考虑的因素有很多，包括字体大小、换行位置等，这些因素会影响段落的大小和形状，进而影响下一个段落的位置。\n布局完成后会输出对应的“盒模型”，它会精确地捕获每个元素的确切位置和大小，将所有相对值都转换为屏幕上的`绝对像素`。(关于像素方面的知识可以参考[css布局心得](http://Appleking10.github.io/2020/06/10/css布局心得（持续更新）))\n\n7.绘制\n绘制就是将渲染树中的每个`节点`转换成屏幕上的`实际像素`的过程。得到布局树这份“施工图”之后，渲染引擎并不能立即绘制，因为还不知道绘制顺序，如果没有弄清楚绘制顺序，那么很可能会导致页面被错误地渲染。例如，对于使用 z-index 属性的元素（如遮罩层）如果未按照正确的顺序绘制，则将导致渲染结果和预期不符（失去遮罩作用）。\n所以绘制过程中的第一步就是**遍历布局树，生成绘制记录，然后渲染引擎会根据绘制记录去绘制相应的内容**。\n> 对于无动画效果的情况，只需要考虑空间维度，生成不同的图层，然后再把这些图层进行合成，最终成为我们看到的页面。当然这个绘制过程并不是静态不变的，会随着页面滚动不断合成新的图形。\n\n### 三. 关于JS的小事\n#### 1. 数据类型的理解\nJavaScript 的数据类型可以分为 7 种：空（Null）、未定义（Undefined）、数字（Number）、字符串（String）、布尔值（Boolean）、符号（Symbol）、对象（Object）。\n\n* 1.undefined\nUndefined 是一个很特殊的数据类型，它只有一个值，也就是 undefined。\n可以通过下面几种方式来得到 undefined：\n> * 引用已声明但未初始化的变量；\n> * 引用未定义的对象属性；\n> * 执行无返回值函数；\n> * 执行 void 表达式；\n> * 全局常量 window.undefined 或 undefined。\n\n推荐通过 void 表达式`void 0`来得到 undefined 值，因为这种方式既简便（window.undefined 或 undefined 常量的字符长度都大于 \"void 0\" 表达式）又不需要引用额外的变量和属性；同时它作为表达式还可以配合三目运算符使用，**代表不执行任何操作**。\n如何判断一个变量的值是否为 undefined 呢？\n```javascript\ntypeof x === 'undefined'\n```\n\n* 2.null\n`Null` 数据类型和 `Undefined` 类似，只有唯一的一个值null，都可以表示空值，甚至我们通过 “==” 来比较它们是否相等的时候得到的结果都是 true，但 null 是 JavaScript 保留关键字，而 undefined 只是一个常量。也就是说可以声明名称为 undefined 的变量（虽然只能在老版本的 IE 浏览器中给它重新赋值），但将 null 作为变量使用时则会报错。\n\n* 3.Boolean\nBoolean数据类型只有两个值：true 和 false。但是常常会将各种表达式和变量转换成 Boolean 数据类型来当作判断条件。\n\n* 4.number\n数值类型，有 2 个特殊数值需要注意一下，即 NaN 和 Infinity。\n> * NaN（Not a Number）通常在计算失败的时候会得到该值。要判断一个变量是否为 NaN，则可以通过 Number.isNaN 函数进行判断。\n> * Infinity 是无穷大，加上负号 “-” 会变成无穷小，在某些场景下比较有用，比如通过数值来表示权重或者优先级，Infinity 可以表示最高优先级或最大权重。\n**精度转换**\n在进行浮点数运算时。比如我们执行简单的运算 0.1 + 0.2，得到的结果是 0.30000000000000004，如果直接和 0.3 作相等判断时就会得到 false。\n出现这种情况的原因在于计算的时候，JavaScript 引擎会先将十进制数转换为二进制，然后进行加法运算，再将所得结果转换为十进制。在进制转换过程中如果小数位是无限的，就会出现误差。同样的，将数字 5 开方后再平方得到的结果也和数字 5 不相等。\n**解决办法**：\n> * 先转换成整数进行计算，然后再转换回小数，这种方式适合在小数位不是很多的时候。比如一些程序的支付功能 API 以“分”为单位，从而避免使用小数进行计算。\n> * 舍弃末尾的小数位。比如对上面的加法就可以先调用 toPrecision 截取 12 位，然后调用 parseFloat 函数转换回浮点数。\n```javascript\nparseFloat((0.1 + 0.2).toPrecision(12)) // 0.3\n```\n\n* 5.string\n\n千位分隔符是指为了方便识别较大数字，每隔三位数会加入一个逗号，该逗号就是千位分隔符。如果要编写一个函数来为输入值的数字添加千分位分隔符，该怎么实现呢？\n一种实现方式是通过 for 循环的索引值找到对应的字符；而另一种方式是通过数组反转，从而变成从左到右操作。\n```javascript\n// 将字符串数据转化成引用类型数据，即用数组来实现\nfunction sep(n) {\n  let [i, c] = n.toString().split(/(\\.\\d+)/)//将数值转换成字符数组\n  // 通过数组反转，从而变成从左到右遍历数值每一位，每隔 3 位添加分隔符\n  return i.split('').reverse().map((c, idx) => (idx+1) % 3 === 0 ? ',' + c: c).reverse().join('').replace(/^,/, '') + c\n}\n// 通过引用类型，即用正则表达式对字符进行替换来实现\nfunction sep2(n){\n  let str = n.toString()\n  str.indexOf('.') < 0 ? str+= '.' : void 0\n  return str.replace(/(\\d)(?=(\\d{3})+\\.)/g, '$1,').replace(/\\.$/, '')\n}\n```\n* 6.symbol\nsymbol 是 ES6 中引入的新数据类型，它表示一个唯一的常量，通过 Symbol 函数来创建对应的数据类型，创建时可以添加`变量描述`，该变量描述在传入时会被强行转换成`字符串`进行存储。\n```javascript\nvar a = Symbol('1')\nvar b = Symbol(1)\na.description === b.description // true\nvar c = Symbol({id: 1})\nc.description // [object Object]\nvar _a = Symbol('1')\n_a == a // false\n```\nsymbol 属性类型比较适合用于两类场景中：常量值和对象属性\n> * 避免常量值重复\n```javascript\nfunction getValue(key) {\n  switch(key){\n    case 'A':\n      //...\n    ...\n    case 'B':\n      //...\n  }\n}\ngetValue('B');\n```\n这段代码对调用者而言非常不友好，因为代码中使用了`魔术字符串`（魔术字符串是指在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值），导致调用 getValue 函数时需要查看函数源码才能找到参数 key 的可选值。所以可以将参数 key 的值以常量的方式声明出来。\n改进：\n```javascript\nconst KEY = {\n  apple: 'A',\n  banana: 'B',\n  ...\n}\nfunction getValue(key) {\n  switch(key){\n    case KEY.apple:\n      ...\n    ...\n    case KEY.banana:\n      ...\n  }\n}\ngetValue(KEY.baidu);\n```\n但这样也并非完美，假设现在我们要在 KEY 常量中加入一个 key，根据对应的规则，很有可能会出现值重复的情况：\n```javascript\nconst KEY = {\n  apple: 'A',\n  banana: 'B',\n  //...\n  bear: 'B'\n}\n//因此可以使用symbol，不关心值本身，只关心值得唯一性\nconst KEY = {\n  apple: Symbol(),\n  banana: Symbol(),\n  //...\n  bear: Symbol()\n}\n```\n> * 避免对象属性覆盖\n假设有这样一个函数 fn，需要对传入的对象参数添加一个临时属性 user，但可能该对象参数中已经有这个属性了，如果直接赋值就会覆盖之前的值。此时就可以使用 Symbol 来避免这个问题。\n```javascript\nfunction fn(o) { // {user: {id: xx, name: yy}}\n  const s = Symbol()\n  o[s] = 'zzz'\n  ...\n}\n```\n* 7.Object\n相对于基础类型，引用类型 Object 则复杂很多。简单地说，Object 类型数据就是键值对的集合，键是一个字符串（或者 Symbol） ，值可以是任意类型的值； 复杂地说，Object 又包括很多子类型，比如 Date、Array、Set、RegExp。\n\n由于引用类型在赋值时只传递指针，这种拷贝方式称为**浅拷贝**。\n而创建一个新的与之相同的引用类型数据的过程称之为**深拷贝**。\n现在我们来实现一个拷贝函数，支持上面 7 种类型的数据拷贝。\n\n对于 6 种基础类型，我们只需简单的赋值即可，而 Object 类型变量需要特殊操作。因为通过等号“=”赋值只是浅拷贝，要实现真正的拷贝操作则需要通过遍历键来赋值对应的值，这个过程中如果遇到 Object 类型还需要再次进行遍历。\n\n```javascript\n// 为了准确判断每种数据类型，我们可以先通过 typeof 来查看每种数据类型的描述\n[undefined, null, true, '', 0, Symbol(), {}].map(it => typeof it)// [\"undefined\", \"object\", \"boolean\", \"string\", \"number\", \"symbol\", \"object\"]\nfunction clone(data) {\n  let result = {}\n// 通过 getOwnPropertyNames 和 getOwnPropertySymbols 函数将键名组合成数组\n  const keys = [...Object.getOwnPropertyNames(data), ...Object.getOwnPropertySymbols(data)]\n  if(!keys.length) return data //判断是否为null\n  keys.forEach(key => {\n    let item = data[key]\n    if (typeof item === 'object' && item) {\n      result[key] = clone(item)//递归\n    } else {\n      result[key] = item\n    }\n  })\n  return result\n}\n//为了避免数据嵌套陷入递归死循环，需要把已添加的对象记录下来\nfunction clone(obj) {\n  let map = new WeakMap()\n  function deep(data) {\n    let result = {}\n    const keys = [...Object.getOwnPropertyNames(data), ...Object.getOwnPropertySymbols(data)]\n    if(!keys.length) return data\n    const exist = map.get(data)\n    if (exist) return exist\n    map.set(data, result)\n    keys.forEach(key => {\n      let item = data[key]\n      if (typeof item === 'object' && item) {\n        result[key] = deep(item)\n      } else {\n        result[key] = item\n      }\n    })\n    return result\n  }\n  return deep(obj)\n}\n```\n\n\n#### 2. 原型和原型链的理解\n* 什么是原型和原型链？\n简单地理解，**原型**就是对象的**属性**，包括被称为`隐式原型的proto属性`和被称为`显式原型的prototype属性`。\n**`隐式原型`通常在创建实例的时候就会自动指向构造函数的`显式原型`**。\n```javascript\nvar a = {}\na.__proto__ === Object.prototype // true\nvar b= new Object()\nb.__proto__ === a.__proto__ // true\n// 当创建对象 a 时，a 的隐式原型会指向构造函数 Object() 的显式原型。\n```\n显式原型是内置函数（比如 Date() 函数）的默认属性，在自定义函数时（箭头函数除外）也会默认生成，生成的显式原型对象只有一个属性 constructor ，该属性指向函数自身。通常配合 new 关键字一起使用，当通过 new 关键字创建函数实例时，会将实例的隐式原型指向构造函数的显式原型。说人话就是**显式原型对象在使用 new 关键字的时候会被自动创建**\n* new 操作符实现了什么？\n```javascript\nfunction F(init) {}\nvar f = new F(args)\n```\n其中主要包含了 3 个步骤：\n* 1.创建一个临时的空对象，为了表述方便，我们命名为 fn，让对象 fn 的`隐式原型(_proto_)`指向函数 F 的`显式原型(prototype)`；\n* 2.执行函数 F()，将 `this` 指向对象 fn，并传入参数 args，得到执行结果 result；\n* 3.判断上一步的执行结果 result，如果 result 为非空对象，则返回 result，否则返回 fn。\n```javascript\n// 即执行了下面代码\nvar fn = Object.create(F.prototype)\nvar obj = F.apply(fn, args)\nvar f = obj && typeof obj === 'object' ? obj : fn;\n```\n* 怎么通过原型链实现多层继承？\n假设构造函数 B() 需要继承构造函数 A()，就可以通过将函数 B() 的显式原型指向一个函数 A() 的实例，然后再对 B 的显式原型进行扩展。那么通过函数 B() 创建的实例，既能访问用函数 B() 的属性 b，也能访问函数 A() 的属性 a，从而实现了多层继承。\n```javascript\nfunction A() {}\nA.prototype.a = function() {\n  return 'a';\n}\nfunction B() {}\nB.prototype = new A(); //B继承了A\nB.prototype.b = function() {\n  return 'b';\n}\nvar c = new B()\nc.b() // 'b'\nc.a() // 'a'\n```\n\n### 四. 关于浏览器我们要注意什么\n\n#### 1. 浏览器加载网络资源的速度提升\n可以通过减少响应内容大小，比如使用 gzip 算法压缩响应体内容和 HTTP/2 的压缩头部功能；另一种更通用也更为重要的技术就是使用**缓存**。\n\n* HTTP缓存\n使用缓存最大的问题往往不在于将资源缓存在什么位置或者如何读写资源，而在于如何保证缓存与实际资源一致的同时，提高缓存的命中率。也就是说尽可能地让浏览器从缓存中获取资源，但同时又要保证被使用的缓存与服务端最新的资源保持一致。\n\n为了达到这个目的，需要制定合适的缓存过期策略（简称“缓存策略”），HTTP 支持的缓存策略有两种：强制缓存和协商缓存。\n`强制缓存`:强制缓存是在浏览器加载资源的时候，先直接从缓存中查找请求结果，如果不存在该缓存结果，则直接向服务端发起请求。\n`协商缓存`:协商缓存的更新策略是不再指定缓存的有效时间了，而是浏览器直接发送请求到服务端进行确认缓存是否更新，如果请求响应返回的 HTTP 状态为 304，则表示缓存仍然有效。控制缓存的难题就是从浏览器端转移到了服务端。\n\n#### 2. 手写promise、async/await\n\n**Promise 状态**\n\n  Promise 的 3 个状态分别为 pending、fulfilled 和 rejected。\n\n  + pending：“等待”状态，可以转移到 fulfilled 或者 rejected 状态\n  + fulfilled：“执行”（或“履行”）状态，是 Promise 的最终态，表示执行成功，该状态下不可再改变。\n  + rejected：“拒绝”状态，是 Promise 的最终态，表示执行失败，该状态不可再改变。\n\n**Promise 解决过程**\n\n  Promise 解决过程是一个抽象的操作，即接收一个 promise 和一个值 x，目的就是对 Promise 形式的执行结果进行统一处理。需要考虑以下 4 种情况。\n\n  + 情况 1： x 等于 promise\n  抛出一个 TypeError 错误，拒绝 promise。\n\n  + 情况 2：x 为 Promise 的实例\n  如果 x 处于等待状态，那么 promise 继续等待至 x 执行或拒绝，否则根据 x 的状态执行/拒绝 promise。\n\n  + 情况 3：x 为对象或函数\n  该情况的核心是取出 x.then 并调用，在调用的时候将 this 指向 x。将 then 回调函数中得到结果 y 传入新的 Promise 解决过程中，形成一个递归调用。其中，如果执行报错，则以对应的错误为原因拒绝 promise。\n  这一步是处理拥有 then() 函数的对象或函数，这类对象或函数我们称之为“thenable”。注意，它只是拥有 then() 函数，并不是 Promise 实例。\n\n  + 情况 4：如果 x 不为对象或函数\n  以 x 作为值，执行 promise。\n\n**Promise 实现**\n  ","tags":["实战心得","持续更新","前端基础"]},{"title":"可以看懂的webpack教程","url":"/2020/10/26/可以看懂的webpack教程/","content":"\n关于webpack，真是让人又爱又恨。作为前台端水的一员，搞懂webpack是必不可少的！\nWebpack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的预编译语言（scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。\n\n一份webpack配置（`webpack.config.js`）包含以下内容:\n+ Entry：**入口**，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。\n+ Module：**模块**，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。\n+ Chunk：**代码块**，一个 Chunk 由多个模块组合而成，用于代码合并与分割。\n+ Loader：**模块转换器**，用于把模块原内容按照需求转换成新内容。\n+ Plugin：**扩展插件**，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。\n+ Output：**输出结果**，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。\n\n**从零开始配置**\n### 首先，当然是需要安装webpack工具\n```\n npm init --yes // 生成一份package.json文件，方便管理版本\n npm i webpack webpack-cli --save-dev // 安装webpack\n```\n\n有了 Webpack 后，就可以直接运行 webpack 命令来打包 JS 模块代码\n```\n npx webpack\n```\n这个命令在执行的过程中，Webpack 会自动从 `src/index.js` 文件开始打包，然后根据代码中的模块导入操作，自动将所有用到的模块代码打包到一起。完成之后，打包后的文件会出现在`dist`文件夹里的`main.js`文件\n\n+ **一个小tips：让vs code支持webpack智能提示**\n我们通过 import 的方式导入 Webpack 模块中的 Configuration 类型，然后根据类型注释的方式将变量标注为这个类型，这样我们在编写这个对象的内部结构时就可以有正确的智能提示了\n```javascript\nimport { Configuration } from 'webpack'\n/**\n * @type {Configuration}\n */\n\n// 或者是这种写法\n/** @type {import('webpack').Configuration} */\n\nmodule.exports = {\n    // some config\n}\n```\n**注意：在配置完成后记得注释掉这段import代码，否则编译会出错。因为node环境还不支持import语句**\n\n### 可以开始自定义配置webpack了\n\n大多数情况下，我们都会有一些自定义的需求，因此，可以新建一个`webpack.config.js`文件来自定义配置webpack。\nwebpack.config.js 是一个运行在 Node.js 环境中的 JS 文件，也就是说我们需要按照 CommonJS 的方式编写代码，这个文件可以导出一个对象，我们可以通过所导出对象的属性完成相应的配置选项。\n```javascript\nmodule.exports = {\n    // some config\n}\n```\n####  自定义入口文件(`entry`)和输出结果(`output`)\n\n```javascript\nconst path = require('path')\n\nmodule.exports = {\n   entry: './src/main.js', // @入口文件 string | object | array\n   output:{                // @输出选项：\n        filename: '[name].[hash].js', // 文件名： string\n        path: path.join(__dirname, 'output'), // 所有输出文件的出口目录\n        publicPath: \"/assets/\", // 构建文件的输出目录\n   },\n   module:{},\n   plugins:[],\n   devServer:{}\n}\n```\n\n#### 理想开发模式\n如果我们每次修改完代码，都是通过命令行手动重复运行 Webpack 命令，从而得到最新的打包结果，那么这样的操作过程根本没有任何开发体验可言。\n理想的开发模式应该是：修改代码 → Webpack 自动打包 → 自动刷新浏览器 → 预览运行结果\n\n##### 曲线救国方案：\n+ Webpack 自动打包：在启动 Webpack 时，添加一个 --watch 的 CLI 参数\n+ 自动刷新浏览器： BrowserSync 就可以帮我们实现文件变化过后浏览器自动刷新的功能。\n```\n # 可以先通过 npm 全局安装 browser-sync 模块，然后再使用这个模块\n npm install browser-sync --global\n browser-sync dist --watch\n```\n它的原理就是 Webpack 监视源代码变化，自动打包源代码到 dist 中，而 dist 中文件的变化又被 BrowserSync 监听了，从而实现自动编译并且自动刷新浏览器的功能，整个过程由两个工具分别监视不同的内容。\n\n##### 配置开发服务器\nwebpack-dev-server 是 Webpack 官方推出的一款开发工具，它提供了一个开发服务器，并且将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起。\n```\n# 安装 webpack-dev-server\n npm install webpack-dev-server --save-dev\n# 运行 webpack-dev-server, --open参数，用于自动唤起浏览器打开我们的应用\n npx webpack-dev-server --open\n```\n配置选项：\n```javascript\ndevServer: {\n    contentBase: path.resolve(__dirname,\"dist\"), // 静态文件目录\n    port: 5000, // 端口号\n    host: 'localhost',\n    contentBase: 'public', // 静态资源路径访问\n    overlay: true,\n    compress: true // 服务器返回浏览器的时候是否启动gzip压缩\n}\n```\n由于 webpack-dev-server 是一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。但是最终上线过后，我们的应用一般又会和后端服务部署到同源地址下。\n那这样就会出现一个非常常见的问题：在实际生产环境中能够直接访问的 API，回到我们的开发环境后，再次访问这些 API 就会产生**跨域**请求问题。\nwebpack-dev-server 就支持直接通过配置的方式，添加代理服务，解决这个问题\n```javascript\ndevServer: {\n    proxy: {\n      '/api': { // \n        target: 'https://www.xxx.com'\n      }\n    }\n}\n```\n此时请求 http://localhost:8080/api/users --> https://www.xxx.com/api/users。\n如果希望请求的地址是 https://www.xxx.com/users ，所以对于代理路径开头的 /api 要重写掉。我们可以添加一个 `pathRewrite` 属性来实现代理路径重写\n```javascript\ndevServer: {\n    proxy: {\n      '/api': { // \n        target: 'https://www.xxx.com',\n        pathRewrite: {\n          '^/api': '' // 替换掉代理地址中的 /api\n        },\n        // 会以实际代理请求地址中的主机名去请求，也就是正常请求这个地址的主机名是什么，实际请求 xxx 时就会设置成什么。\n         changeOrigin: true,\n         \n      }\n    }\n}\n```\n此时请求 http://localhost:8080/api/users --> https://wwww.xxx.com/users。\n\n##### 这样的配置代码才能调试\n运行webpack命令后，打开调试器查看源代码，会发现source/index.js都是压缩过的代码，难以进行调试（比如打断点）。\n通过Source Map可以解决这个问题（原理大概就是逆向转译成源码）\n```javascript\nmodule.exports = {\n  devtool: 'source-map' // source map 设置\n}\n```\n+ source-map: 把映射文件生成到单独的文件，最完整最慢\n+ cheap-module-source-map: 在一个单独的文件中产生一个不带列映射的Map\n+ eval-source-map: 使用eval打包源文件模块,在同一个文件中生成完整sourcemap\n+ cheap-module-eval-source-map: sourcemap和打包后的JS同行显示，没有映射列\n现阶段 Webpack 支持的 Source Map 模式有很多种。每种模式下所生成的 Source Map 效果和生成速度都不一样\n可以从[官方文档](https://webpack.js.org/configuration/devtool/#devtool)参考不同模式的效率。\n\n> tip： Eval模式\n> Webpack 会将每个模块转换后的代码都放到 eval 函数中执行，并且通过 sourceURL 声明对应的文件路径，这样浏览器就能知道某一行代码到底是在源代码的哪个文件中。因为在 eval 模式下并不会生成 Source Map文件，所以它的构建速度最快，但是缺点同样明显：它只能定位源代码的文件路径，无法知道具体的行列信息。\n\n##### 这样的配置调试起来更方便\n解决完开发环境会产生的跨域和源码不可暴露调试的问题，还有一个常见的问题还没有解决。\n在调试中，经常遇到因为修改了一处小细节（比如css样式），调整后，基于上面的设置，页面会自动刷新，那前面调试的步骤就会丢失，又要重复去进行调试步骤。\n\n出现这个问题的原因，是因为**我们每次修改完代码，Webpack 都可以监视到变化，然后自动打包，再通知浏览器自动刷新，一旦页面整体刷新，那页面中的任何操作状态都将会丢失**，所以才会出现我们上面所看到的情况。\n\n如果能够实现在页面不刷新的情况下，代码也可以及时的更新到浏览器的页面中，重新执行，避免页面状态丢失，那就最好了！\n**`模块热替换（HMR）`**就可以实现这个需求！\n\n使用这个特性最简单的方式就是，在运行 ``webpack-dev-server`` 命令时，通过`` --hot ``参数去开启这个特性\n或者\n```javascript\nconst webpack = require('webpack')\n\nmodule.exports = {\n  // ...\n  devServer: {\n    // 开启 HMR 特性，如果资源不支持 HMR 会 fallback 到 live reloading\n    hot: true\n    // 只使用 HMR，不会 fallback 到 live reloading\n    // hotOnly: true\n  },\n  plugins: [\n    // ...\n    // HMR 特性所需要的插件\n    new webpack.HotModuleReplacementPlugin()\n  ]\n}\n```\n对于css文件的热替换，不会出现什么问题，对于js文件的热替换，还需要手动配合webpack\n```javascript\n module.hot.accept('./user', () => {\n    // 图片的热替换也是一样的写法\n  })\n```\n\n#### 配置不同环境的打包命令\n通过修改`package.json`，可以简化在不同环境下要执行的打包任务\n\n```\n\"script\": {\n    \"build\": \"webpack --mode production\", // 开启代码压缩，用于生产环境\n    \"dev\": \"webpack-dev-sever --open --mode development\" // 热加载，用于开发环境\n}\n```\n\n#### 支持各种框架和预编译语言\n+ 处理css，sass，以及css3属性前缀\n```\n// cmd\nnpm install style-loader css-loader postcss-loader autoprefixer -D\n\n// webpack.config.json\nmodule.exports = {\n    // ...\n    module: {\n        rules:[\n            // 处理css\n            {\n                test: /\\.css$/,\n                exclude: /node_modules/,\n                include: path.resolve(__dirname,'src'), // 限制范围，提高打包速度\n                use: [\n                    // 多个loader是有顺序的，从后往前写\n                    {\n                        loader: \"style-loader\",\n                        options:{\n                            singleton: true // 处理为单个style标签\n                        }\n                    },\n                    {\n                        loader: \"css-loader\",\n                    },\n                    {\n                        loader: \"postcss-loader\",\n                    }\n                ]\n            },\n            // 处理scss文件：将sass编译成css，再将css转成CommonJS模块，再将js字符串转成style节点\n            {\n                test: /\\.scss$/,\n                use:['style-loader','css-loader','sass-loader']\n            }\n        ]\n    }\n}\n\n// 处理css前缀：新建一个postcss.config.js\nmodule.exports = {\n    plugins: [\n        require('autoprefixer')\n    ]\n}\n```\n\n+ 支持ES6,react,vue\n```\n// cmd\nnpm install babel-loader @babel/core @babel/preset-env @babel/preset-react -D\n\n// webpack.config.json\nmodule.exports = {\n    // ...\n    module: {\n        rules:[\n            // ...\n            {\n                test: /\\.jsx?$/,\n                exclude: /node_modules/,\n                use: [\n                    {\n                        loader: \"babel-loader\"\n                    }\n                ]\n            }\n        ]\n    }\n}\n\n// .babelrc\n{\n    \"presets\": [\"@babel/core\", \"@babel/preset-env\", \"@babel/preset-react\"]\n}\n```\n\n#### 常见的加分配置\n\n+ 提取css文件为单独文件\n+ 产出html\n+ 处理引用第三方库，将第三方库全局变量暴露出来使用\n+ 懒加载（按需加载）\n+ 图片处理： 将小图片使用base64编码，大图片使用file-loader\n+ 全局注入环境变量：编译的时候将定义的变量替换成对应的字符串\n\n### webpack进阶部分\n\n#### Tree Shaking\n摇到未引用和冗余的代码，使用 Webpack 生产模式打包的优化过程中，就使用自动开启这个功能。\nTree-shaking 的本身没有太多需要你理解和思考的地方，你只需要了解它的效果，以及相关的配置即可。\n#### sideEffects\nWebpack 4 中新增了一个 sideEffects 特性，它允许我们通过配置标识我们的代码是否有副作用，从而提供更大的压缩空间。\n> TIPS：模块的副作用指的就是模块执行的时候除了导出成员，是否还做了其他的事情\nTree-shaking 只能移除没有用到的代码成员，而想要完整移除没有用到的模块，那就需要开启 sideEffects 特性了。\n> TIPS：注意这个特性在 production 模式下同样会自动开启。\n```javascript\nmodule.exports = {\n  mode: 'none',\n  entry: './src/main.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  optimization: {\n    sideEffects: true\n  }\n}\n```\nsideEffects 可能需要花点时间去理解一下，重点就是想明白哪些副作用代码是可以随着模块的移除而移除，哪些又是不可以移除的。总结下来其实也很简单：对全局有影响的副作用代码不能移除，而只是对模块有影响的副作用代码就可以移除。\n所以，**尽可能不要写影响全局的副作用代码**。\n#### Code Splitting（代码分割）\n为了解决打包结果过大导致的问题，webpack提供了一种分包功能————代码分割\n+ 多入口打包\n划分规则就是一个页面对应一个打包入口，对于不同页面间公用的部分，再提取到公共的结果中\n```javascript\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  entry: {\n    index: './src/index.js',\n    album: './src/album.js'\n  },\n  output: {\n    filename: '[name].bundle.js' // [name] 是入口名称\n  },\n  // ... 其他配置\n  plugins: [\n    new HtmlWebpackPlugin({\n      title: 'Multi Entry',\n      template: './src/index.html',\n      filename: 'index.html',\n      chunks: ['index'] // 指定使用 index.bundle.js\n    }),\n    new HtmlWebpackPlugin({\n      title: 'Multi Entry',\n      template: './src/album.html',\n      filename: 'album.html',\n      chunks: ['album'] // 指定使用 album.bundle.js\n    })\n  ]\n}\n```\n一般 entry 属性中只会配置一个打包入口，如果我们需要配置多个入口，可以把 entry 定义成一个对象。一旦我们的入口配置为多入口形式，那输出文件名也需要修改，因为两个入口就有两个打包结果，不能都叫 bundle.js。我们可以在这里使用 [name] 这种占位符来输出动态的文件名，[name] 最终会被替换为入口的名称。\n\n+ 抽取公共模块\n```javascript\nmodule.exports = {\n  entry: {},\n  output: {},\n  optimization: {\n    splitChunks: {\n      // 自动提取所有公共模块到单独 bundle\n      chunks: 'all'\n    }\n  }\n}\n```\n\n","tags":["技能篇"]},{"title":"程序员必备算法基础","url":"/2020/09/18/程序员必备算法基础/","content":"### 一.复杂度\n\n#### 1. 复杂度是什么\n\n**复杂度**是衡量代码运行效率的重要的度量因素。\n先看一下**复杂度**和计算机**实际任务处理效率**的关系，从而了解降低复杂度的必要性。\n\n计算机通过一个个程序去执行计算任务，也就是对输入数据进行加工处理，并最终得到结果的过程。每个程序都是由代码构成的。可见，编写代码的核心就是要完成计算。但对于同一个计算任务，不同计算方法得到结果的过程复杂程度是不一样的，这对你实际的任务处理效率就有了非常大的影响。\n举个例子，你要在一个在线系统中实时处理数据。假设这个系统平均每分钟会新增 300M 的数据量。如果你的代码不能在 1 分钟内完成对这 300M 数据的处理，那么这个系统就会发生时间爆炸和空间爆炸。表现就是，电脑执行越来越慢，直到死机。因此，我们需要讲究合理的计算方法，去通过尽可能低复杂程度的代码完成计算任务。\n\n那如何降低复杂程度呢，我们首先需要知道怎么衡量复杂度。而在实际衡量时，我们通常会围绕以下2 个维度进行。\n首先，*这段代码消耗的资源是什么*。一般而言，代码执行过程中会消耗计算时间和计算空间，那需要衡量的就是\n* 时间复杂度\n* 空间复杂度。\n\n其次，*这段代码对于资源的消耗是多少*。不能只看当前资源消耗了多少，因为不管是时间还是空间，它们的消耗都和输入量有很大关系。为了更客观地衡量消耗程度，我们通常会关注时间或者**空间消耗量**与**输入数据量**之间的关系。\n\n复杂度是一个关于输入数据量 n 的函数。假设你的代码复杂度是 f(n)，即 O(f(n))。例如，O(n) 表示的是，复杂度与计算实例的个数 n 线性相关；O(logn) 表示的是，复杂度与计算实例的个数 n 对数相关。\n\n通常，复杂度的计算方法遵循以下几个原则：\n* 首先，复杂度与具体的常系数无关，例如 O(n) 和 O(2n) 表示的是同样的复杂度。我们详细分析下，O(2n) 等于 O(n+n)，也等于 O(n) + O(n)。也就是说，一段 O(n) 复杂度的代码只是先后执行两遍 O(n)，其复杂度是一致的。\n* 其次，多项式级的复杂度相加的时候，选择高者作为结果，例如 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。具体分析一下就是，O(n²)+O(n) = O(n²+n)。随着 n 越来越大，二阶多项式的变化率是要比一阶多项式更大的。因此，只需要通过更大变化率的二阶多项式来表征复杂度就可以了。\n\n> O(1) 也是表示一个特殊复杂度，含义为某个任务通过有限可数的资源即可完成。此处有限可数的具体意义是:数据量多少和资源消耗无关。\n\n#### 2.时间复杂度与代码结构的关系\n\n代码的时间复杂度，与代码的结构有非常强的关系。举个栗子：\n\n```javascript\nfunction getMaxVal(arr) {\n    let max_val = -1;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] > max_val) {\n            max_val = a[i];\n        }\n    }\n    return max_val\n}\n```\n暂存当前最大值并把所有元素遍历一遍即可。因为代码的结构上需要使用一个 for 循环，对数组所有元素处理一遍，所以时间复杂度为 O(n)。\n\n下面的代码定义了一个数组 a = [1, 3, 4, 3, 4, 1, 3]，并会在这个数组中查找出现次数最多的那个数字\n```javascript\nfunction getMostVal(arr = [1, 3, 4, 3, 4, 1, 3 ] ) {\n    let val_max = -1;\n    let time_max = 0;\n    let time_tmp = 0;\n    for (int i = 0; i < arr.length; i++) {\n        time_tmp = 0;\n        for (let j = 0; j < arr.length; j++) {\n            if (arr[i] == arr[j]) {\n            time_tmp += 1;\n        }\n        if (time_tmp > time_max) {\n            time_max = time_tmp;\n            val_max = arr[i];\n        }\n        }\n    }\n   return val_max;\n}\n```\n这段代码中，我们采用了两重循环的方式计算：第一层循环，对数组中每个元素进行遍历；第二层循环，对于每个元素计算出现的次数，并且通过当前元素次数 `time_tmp` 和全局最大次数变量 `time_max` 的大小关系，保存出现次数最多的那个元素及其出现次数。由于是两重循环，这段代码在时间复杂度是 n*n，也就是 O(n²)。\n\n通过一些经验，我们可以得出一些结论：\n* 一个顺序结构的代码，时间复杂度是 O(1)。\n* 二分查找（分而治之的二分策略），时间复杂度都是 O(logn)。\n* 一个简单的 for 循环，时间复杂度是 O(n)。\n* 两个顺序执行的 for 循环，时间复杂度是 O(n)+O(n)=O(2n)，其实也是 O(n)。\n* 两个嵌套的 for 循环，时间复杂度是 O(n²)。\n\n#### 3.降低时间复杂度的必要性\n\n假设某个计算任务需要处理 10万 条数据。你编写的代码：\n* 如果是 O(n²) 的时间复杂度，那么计算的次数就大概是 100 亿次左右。\n* 如果是 O(n)，那么计算的次数就是 10万 次左右。\n* 如果这个工程师再厉害一些，能在 O(log n) 的复杂度下完成任务，那么计算的次数就是 17 次左右。\n \n通常在小数据量的计算上，时间复杂度的降低在绝对处理时间上没有太多体现。但在当今的大数据环境下，时间复杂度的优化将会带来巨大的系统收益。\n\n### 二.学会将时间复杂度转换成空间复杂度\n\n在两全其美的情况下，要采用尽可能低的时间复杂度和空间复杂度，去完成一段代码的开发。但有时候只能选择牺牲一部分来找到最佳编码方法。\n\n#### 要诀：时间昂贵、空间廉价\n一段代码会消耗计算时间、资源空间，从而产生时间复杂度和空间复杂度。\n假设一段代码经过优化后，虽然降低了时间复杂度，但依然需要消耗非常高的空间复杂度。 例如，对于固定数据量的输入，这段代码需要消耗几十 G 的内存空间，很显然普通计算机根本无法完成这样的计算。如果一定要解决的话，一个最简单粗暴的办法就是，购买大量的高性能计算机，来弥补空间性能的不足。\n这告诉我们一个什么样的现实问题呢？代码效率的瓶颈可能发生在时间或者空间两个方面。如果是缺少计算空间，花钱买服务器就可以了。这是个花钱就能解决的问题。相反，如果是缺少计算时间，只能投入**宝贵的人生**去跑程序。即使你有再多的钱、再多的服务器，也是毫无用处。相比于空间复杂度，时间复杂度的降低就显得更加重要了。因此，你会发现这样的结论：**空间是廉价的，而时间是昂贵的。**\n\n#### 程序优化的具体思路：\n\n* 第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。\n\n* 第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。\n\n* 第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。\n\n举个栗子：\n查找出一个数组中，出现次数最多的那个元素的数值。\n```javascript\n// 暴力解法：\nfunction getMostVal( arr = [1, 3, 4, 3, 4, 1, 3 ]) {\n    let val_max = -1;\n    let time_max = 0;\n    let time_tmp = 0;\n    for (int i = 0; i < arr.length; i++) {\n        time_tmp = 0;\n        for (let j = 0; j < arr.length; j++) {\n            if (arr[i] == arr[j]) {\n            time_tmp += 1;\n        }\n        if (time_tmp > time_max) {\n            time_max = time_tmp;\n            val_max = arr[i];\n        }\n        }\n    }\n   return val_max;\n}\n```\n采用了两层的 for 循环，很显然时间复杂度就是 O(n²)。而且代码中，几乎没有冗余的无效计算。如果还需要再去优化，就要考虑采用一些`数据结构`方面的手段，来把时间复杂度转移到空间复杂度了。\n\n```javascript\nfunction getMostVal( arr = [1, 3, 4, 3, 4, 1, 3 ]) {\n    let d = new Map();\n    for (let i = 0; i < a.length; i++) {\n        if (d.has(a[i])) {\n            d.set(a[i], d.get(a[i]) + 1);\n        } else {\n            d.set(a[i], 1);\n        }\n    }\n    let val_max = -1;\n    let time_max = 0;\n    for(let key in d){\n        if (d.get(key) > time_max) {\n            time_max = d.get(key);\n            val_max = key;\n        }\n    }\n    return val_max;\n}\n```\n代码结构上，有两个 for 循环。不过，这两个循环不是嵌套关系，而是顺序执行关系。其中，第一个循环实现了数组转map的过程，也就是 O(n) 的复杂度。第二个循环再次遍历map找到出现次数最多的那个元素，也是一个 O(n) 的时间复杂度。\n\n#### 分析过程 -- 3个步骤\n* 首先，这段代码对数据进行了哪些操作？（增删查）\n* 其次，这些操作中，哪个操作最影响效率，对时间复杂度的损耗最大？\n* 最后，哪种数据结构最能提高数据操作的使用效率？\n\n### 三.线性表结构的增删查\n\n#### 1.线性表\n大概是这样的东西：|￣1￣|-->|￣2￣|-->...\n \n在链表的最前面，通常会有个头指针用来指向第一个结点。对于链表的最后一个结点，由于在它之后没有下一个结点，因此它的指针是个空指针。链表结构，和小朋友手拉手站成一排的场景是非常相似的。\n从单链表又衍生出了循环链表、双向链表等\n\n#### 2.线性表对于数据的增删查\n1. 单链表\n* **增** ：只需要把待插入结点的指针指向原指针的目标，把原来的指针指向待插入的结点\n* **删** ：如果待删除的结点为 b，那么只需要把指向 b 的指针 （p.next），指向 b 的指针指向的结点（p.next.next）\n* **查** ：一个个指向去查找\n2. 栈（后进先出 ）\n3. 队列\n4. 二叉树\n5. 哈希表\n\n#### 3.算法思维基础\n1. 递归\n2. 分而治之（二分法）\n3. 排序算法\n4. 动态规划\n* 分阶段 -> 找状态 -> 做决策 -> 状态转移方程 -> 定目标 -> 寻找终止条件\n例：输入两个字符串，用动态规划的方法，求解出最大公共子串。\n> 例如，输入 a = \"13452439\"， b = \"123456\"。由于字符串\"345\"同时在 a 和 b 中出现，且是同时出现在 a 和 b 中的最长的子串。因此输出\"345\"。\n具体分析一下动态规划的步骤:\n> * 对于一个可能的起点，它后面的每个字符都是一个阶段。\n> * 状态就是当前寻找到的相匹配的字符。\n> * 决策就是当前找到的字符是否相等（相等则进入到公共子串中）。\n> * 状态转移方程可以写作 `sk+1 = uk(sk)`。可以理解为，如果 sk = \"123\"是公共子串，且在 a 字符串和 b 字符串中，\"123\"后面的字符相等，假设为\"4\"，则决策要进入到公共子串中，sk+1 = \"1234\"。\n> * 目标自然就是公共子串最长。\n> * 终止条件就是决策到了不相等的结果\n\n\n","tags":["技能篇","前端基础"]},{"title":"css布局心得（持续更新）","url":"/2020/08/10/css布局心得（持续更新）/","content":"\n### 移动端布局\n\n#### 关于像素的那些事\n\n* css像素（CSS Pixel）： 虚拟像素，浏览器内的一切长度都是以css像素为单位，是相对单位（也就是说会变化的）\n* 物理像素（dp）: 也就是我们所说的屏幕分辨率，在设备出厂的时候，屏幕含有多少个物理像素点已经是确定，这些像素点的大小也是固定的了。（*但像素点的大小不是固定的，比如同样的尺寸下可以有不同的分辨率，说明这个屏幕下的像素点数量不同，那每个像素点大小肯定是不一样的*）\n  \n* 设备像素比（DPR）= 物理像素/css像素，含义是几个物理像素对应一个css像素。UI给的几倍图就是要看当前设备的DPR多少来设定。\n\n* **为什么要有几倍图呢？** 举例说明一下，假设设计师给我们一份100*100px的设计稿，此时设备DPR=1说明1个物理像素对应1个css像素，也就是css在浏览器画出来的1px == 设计稿上的1px == 设备显示的1px。当DPR=2说明4个物理像素对应1个css像素，也就是css在浏览器画出来的1px == 设备显示的2px == 设计稿的2px，所以，我们需要将css像素缩小一倍，即0.5px；当dpr=3时，是0.3333px\n*  **浏览器按住ctrl和+时候放大，改变的是谁？页面为啥会放大？** 在dpr=1，缩放比=1的时候，一个css像素对应一个物理像素。用一个10px*10px的div来举例（css里面设定的），浏览器页面放大的时候，可以看到这个div放大了，用审查元素去看，width和height还是10px，那是谁影响了大小呢。首先可以排除物理像素，上面已经说了，物理像素是出厂的时候就已经决定的大小，是不变了。所以只能是css像素大小改变，css是相对单位， **这时候的一个css像素对应的物理像素更多了** ，这就是为什么我们看起来更大了的原因。\n\n### 常见布局\n\n我们通常提到的布局，有两个共同点：\n\n* 大多数用于 PC 端，因为 PC 端屏幕像素宽度够大，可布局的空间也大；\n* 布局是有限空间内的元素排列方式，因为页面设计横向不滚动，纵向无限延伸，所以大多数时候讨论的布局都是对水平方向进行分割。\n\n实际上我们在讨论布局的时候，会把网页上特定的区域进行分列操作。按照分列数目，可以大致分为 3 类，即单列布局、2 列布局、3 列布局。\n\n#### 1.单列布局\n\n单列布局是最常用的一种布局，它的实现效果就是将``一个元素``作为布局容器，通常设置一个较小的（最大）宽度来保证不同像素宽度屏幕下显示一致。\n这种布局的优势在于基本上可以适配超过布局容器宽度的各种显示屏幕，比如网站布局容器宽度为 700px，也就是说超过 700px 宽度的显示屏幕上浏览网站看到的效果是一致的。\n但它最大的缺点也是源于此，过度的冗余设计必然会带来**浪费**。例如，在上面的例子中，其实我的屏幕宽度是足够的，可以显示更多的内容，但是页面两侧却出现了大量空白区域，如果在 4k 甚至更宽的屏幕下，空白区域大小会超过页面内容区域大小！\n\n#### 2.两列布局\n\n2列布局使用频率也非常的高，实现效果就是将页面分割成左右宽度不等的`两列`，宽度较小的列设置为固定宽度，剩余宽度由另一列撑满。为了描述方便，我们暂且称宽度较小的列父元素为`次要布局容器`，宽度较大的列父元素为`主要布局容器`。\n\n示例网站：\n![两列布局](https://wx1.sbimg.cn/2020/06/10/vue.png)\n\n这种布局适用于内容上具有明显主次关系的网页，比如 API 文档页面中左侧显示内容导航，右侧显示文档描述；又比如后台管理系统中左侧显示菜单栏，右侧显示配置页面。相对于单列布局，在屏幕宽度适配方面处理得更好。当屏幕宽度不够时，主要内容布局容器优先显示，次要内容布局容器改为垂直方向显示或隐藏，但有时候也会和单列布局搭配使用，作为单列布局中的子布局使用。\n\n#### 3.三列布局\n3 列布局按照左中右的顺序进行排列，通常中间列最宽，左右两列次之。\n\n实例网站：\n![三列布局](https://wx1.sbimg.cn/2020/06/10/github.png)\n\n\n### 如何避免样式冲突\n\n#### 1. 手动命名\n最简单有效的命名管理方式就是制定一些命名规则，比如`BEM`\n`BEM`: BEM 是 Block、Element、Modifier 三个单词的缩写，Block 代表独立的功能组件，Element 代表功能组件的一个组成部分，Modifier 对应状态信息。\n```html\n<button class=\"button\"></button>\n<button class=\"button button-state-success\"></button> \n<button class=\"button button-state-danger\"></button> \n```\n#### 2. 工具命名\n通过插件将原命名转化成不重复的随机命名，从根本上避免命名冲突。比较著名的解决方案就是 CSS Modules。\n\n```css\n.className {\n  color: green;\n}\n```\n借助 css Modules 插件，可以将 css 以 JSON 对象的形式引用和使用。\n```javascript\nimport styles from \"./style.css\";\n// import { className } from \"./style.css\";\nelement.innerHTML = '<div class=\"' + styles.className + '\">';\n```\n编译之后的代码，样式类名被转化成了随机名称。但这种命名方式带来了一个问题，那就是如果想在引用组件的同时，覆盖它的样式会变得困难，因为编译后的样式名是随机。","tags":["CSS","实战心得","持续更新"]},{"title":"vue项目开发中遇到的坑和心得（持续更新）","url":"/2020/06/21/vue项目开发中遇到的坑和心得/","content":"\n### 前言\n\n从学vue到工作中用到vue也有半年多，感觉很有必要来总结一下具体工作场景中遇到的一些坑已经填坑的过程。\n\n---\n\n#### 怎么处理数据量大的变量？\n\n* 场景： 在应用场景中，有时候需要将一整个数据或者对象保存下来，给其它函数使用，一般来说只是展示使用。但如果放在`data()`中，其实对整个页面和浏览器不太友好。\n* 原因： 众所周知，存放在`data()`中的变量，在vue的生命周期中会被实时监听而且是每一项都会被监听到，所以一个存储数据量很大且其实不需要被监听的变量就会给页面造成负担。\n* 方法： 研究vue的生命周期可以知道，`data()`是在`created()`中初始化完成的，在`create()`声明一个变量，也能全局使用，但不会被实时监听到，减小性能损耗\n  \n```javascript\ncreate(){\n    this.arr = null;//也能全局使用\n}\n```\n\n#### Vue自定义插件的构造\n\n* 场景： 日常中我们要使用一个组件（比如弹窗组件）的方式通常是先通过Vue.component 全局或是 component 局部注册后，然后在模版中使用。但操作流程还是不够简洁方便。于是借鉴了element-ui的写法，去研究如何挂载自定义模板\n* Vue.extend(options)\n  * 描述： **Vue.extend**返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上。\n  * 参数类型：Object\n* 用法\n  * 原理：运用Vue.extend()方法，注册挂载自定义模板，并将模板显示方法挂载到Vue原型上，方便全局调用。Vue.extend 的显示与否是手动的去做组件的挂载和销毁。\n  * 实战\n   **1.alert.vue** //弹窗模板\n\n```javascript\n<template>\n    <div id=\"alert\" v-if=\"msg\">\n        <span class=\"icon\">❕</span>\n        <span>{{msg}}</span>\n    </div>\n</template>\n<script>\nexport default {\n    props: {\n        msg: null //显示信息\n    },\n    watch: {\n        msg: function(val) {\n            if (val) {\n                let _self = this;\n                setTimeout(function() {\n                    $('#alert).css({transform: \"translate(-50%,0)\",opacity:1})\n                }, 0);\n                setTimeout(function() {\n                    $('#alert).css(\"opacity\",0)\n                }, 2000);\n                setTimeout(function() {\n                    _self.msg = null;\n                    $('#alert).css(\"display\",\"none\").remove() //移除dom元素\n                    // _self.$destroy(); //若允许生成多个实例便在用完的时候需要销毁\n                }, 3000);\n            }\n        }\n    }\n};\n</script>\n<style scoped>\n#alert{\n    min-width: 200px;\n    min-height: 30px;\n    color: slategray;\n    line-height: 30px;\n    padding: 10px;\n    font-size: 14px;\n    position: fixed;\n    top:20px;\n    left:50%;\n    opacity: 0;\n    transform: translate(-50%,-40px);\n    background: rgb(237,242,252);\n    transition: all 1s ease; \n}\n</style>\n```\n\n  **2.alert.js** //将创建构造器和挂载到目标元素上的逻辑抽离出来，多处可以复用\n  实例化时可以向这个实例传入参数，但是需要注意的是 props 的值需要通过 propsData 属性来传递\n```javascript\nimport Alert from './alert.vue'\nimport Vue from 'vue'\n\nlet Toast = {}; //定义插件对象\nToast.install = function (Vue, options) { //vue的install方法，用于定义vue插件\n  let AlertConstructor = Vue.extend(Alert) //创建vue构造器\n  let instance //保存vue实例\n  let seed = 1; //实例id\n  let index = 999; //模板的z-index\n  let alertObj = {} //保存$alert对象\n  instance = new AlertConstructor() //实例化vue实例\n  instance.vm = instance.$mount() //拿到实例\n  Object.defineProperty(Vue.prototype, \"$alert\", { //挂载到vue原型上，方便全局调用\n\n    get() { //当访问该属性时，会调用get函数\n      alertObj.alertMsg = options => { //调用$alert.alertMsg时\n        let id = 'message_' + seed++\n        instance.id = id //绑上实例id\n        //实例传入参数，对应的是props里面的数据\n        Object.assign(instance, options)\n        index++\n        document.body.appendChild(instance.vm.$el) //将实例的html模板append到html\n        instance.vm.$nextTick(() => { //等dom视图刷新完毕\n          instance.vm.$el.style.zIndex = index\n        })\n        return instance.vm.$alert\n      }\n      alertObj.sh = () => {\n        console.log(\"something\") //自定义方法\n      }\n      return alertObj //返回vue实例\n    }\n  })\n}\nexport default Toast\n```\n\n  **3.main.js** //项目的全局文件引用\n```javascript\nimport Alert from './main/alert1'\nVue.use(Alert)\n```\n\n   4.然后就可以在项目里面使用了，`this.$alert.alertMsg({msg:\"something\"})`\n\n#### 避免滥用this去读取data中数据","tags":["实战心得","持续更新","VUE"]},{"title":"前端发展史","url":"/2020/05/15/前端发展史/","content":"\n### 1. 洪荒时代（1990~1994）\n\n  * 前端大事件：WWW、浏览器、JavaScript的诞生  \n  *\n  1990年，世界上出现了第一个**web浏览器**（世界上第一张网页： [http://info.cern.ch/](http://info.cern.ch/)） ，此时的浏览器页面全是由后端开发的。在后端动态生成页面，但显然，这带来一个明显的缺憾：每次更新都要整页刷新，加上早期的网速情况，这个操作是非常慢的。因此针对这情况，人们从多方面着手改进：编写语言的升级、浏览器的升级、HTML的升级。<br>于是出现了**JavaScript**语言，传闻发明者只用了10天来设计开发出这个语言，工期太短导致许多瑕疵，比如没有包管理机制，也没有像Java与C++那样的打辅助用的SDK，内置的方法也屈指可数。因此一直被程序员嫌弃，所以早期浏览器都配有一个选项，禁止JavaScript语言运行。\n  \n### 2. 前端的统一与分割（1994~1999）\n  * 三场战争：IE浏览器vs网景浏览器、IE浏览vs火狐浏览器、IE浏览器vs谷歌浏览器\n  *  \n  1996年，css的出现，意味着正式开始出现**前端**，这个时候前端的html负责页面结构，决定着网页的结构和内容，是整个网页的躯壳，css负责样式部分，他决定了网站看起来是什么样子，属于前端的皮肤吧，js控制网页的行为，决定做什么一般来说，js负责调用一些前端计算与动态加载，应该属于整个网页的灵魂。只有这三个同时具备的，才能算是一个真正的网站前端。\n  但这时候前端的**问题**依旧存在，复用性差，不能局部加载，所以不久，微软推出了iframe标签，实现了异步的局部加载，就是相当于在网页中嵌套一个网页，切换目录只是切换iframe中的网页\n  \n### 3. 动态页面的崛起（1999-2016）\n  > 再之后99年W3C发布了第四代HTML标准，同年微软推出用于异步数据传输的ActiveX，意味着**ajax**的诞生，这在前端史上同样是个里程碑的事件，之前的iframe中部分加载，其实还是直接加载某个完整的html界面（假如网速很慢，还是会出现空白loading的过程）。而ajax则可以让我们实现真正意义上的局部加载，而不用对整个界面重新进行渲染，极大的优化了用户体验。使用ajax技术，也实现了将从数据库查回的数据可以放到客户端浏览器上进行，所以ajax的出现，并不仅仅优化了用户体验，他将很大一部分计算从服务器挪到了前端，使前端能够完成了更多的工作。为日后的前后端分离提供了技术支持。\n  * **前jquery时代（2009-2012）**：然后一直到09年的时候，前端一直稳定发展，没有进行什么大的改变，这段时间市面上主要有两款浏览器，我们称之为IE浏览器和非ie浏览器，所谓神仙打架凡人遭殃，ie浏览器为了抢夺网景公司的市场，开发出了javascript的变种，jscript。虽然两个基本上完全一样，但是语法糖上可能还是有些许的差别，所以，那个时代的前端工程师他们的主要工作就是画页面和踩各种坑，那个时代一个阅历丰富的程序员的一个标志就是熟练掌握两种浏览器之间的差别，且能找到兼容的方法，jquery的出现在一定程度上缓解了这个问题，正如jquery的logo显示的一样，**write less do more** 。他致力于用更少的代码实现更多的功能。 jquery其实是一个脚本库，jQuery抽象了复杂的代码和浏览器怪异模式，兼容不同的浏览器，用简短的代码实现动效，用链式语法风格减少了程序员的代码量。使我们有时间做重要的事情。jquery的流行降低了前端门槛，让更多人进入这行业，前端工程师的队伍越来越壮大。\n  * **后jquery时代（2012-2016）**：jQuery的发展使前端行业不断涌现出优秀的工程师，他们创造了大量**jQuery插件与UI库**。但也导致了一个问题：前端工程师通常编写一个页面，会引入十多个乃至几十个jQuery插件，页面上塞满了Script标签。众所周知，浏览器是单线程，Script的加载，会影响到页面的解析与呈现，导致著名的白屏问题（当时前端用力过猛，body中的所有东西都是动态生成的）。还有一个问题使全局变量**污染**，因此后jQuery时代来了。人们研发前端模块加载、统一异步机制、 打造大型MVC框架（model-view-controller）， 甚至伸向后端，接管打包脚本而发明Node.js，来腾出大量时间。\n  \n### 4. 三大框架割据时代（2016~至今）\n  * 三大框架：React，Angulat，Vue\n  * 从前端走向全栈：**MVVM框架（Model-View-ViewModel）**是在 MVC 的基础上演进过来的，去掉了 MVC 中的 Controller，增加了数据的双向绑定。对开发者来说，就可以从以前的dom操作中解放出来，想想以前的操作模式，接收到后台的数据，jquery开干，选择dom，拿到数据，拼接字符串，填充到dom中。视图数据变化了，js 每次需要主动重新取值，有了MVVM这都不需要了，做好了双向绑定。只要将数据绑定到MV，V自动更新，V表单或状态发生变化，M自动更新，没有了中间的DOM操作和控制。一切都变得简单。相互之间也没有耦合，对前端性能也是质的提升。","tags":["前端科普"]},{"title":"《高效能人士的七个习惯》读后感","url":"/2020/04/21/《高效能人士的七个习惯》读后感/","content":"\n工作中或许常常有这样的感觉：时间不够用，工作做不完，每时每刻手边总会有许多事情需要去处理，比如回邮件、写文档、敲代码、学知识、开会等等。所以你常常会忙得焦头烂额，但有些人就可以工作得有条不紊，分得清轻重缓急并能够合理的分配时间。其实人和人之间在工作上并没有不可逾越的差别，如果自己也能够严格要求自己，养成良好的工作习惯，就不用自叹不如了。确实，通过阅读《高效能人士的七个习惯》可以帮助自己更大的发挥自己的个人效能和人际效能。\n\n书中作者主张人应该积极主动的改变自己的思维方式，把行为形成习惯，用习惯去影响人生，让我想起之前看过的书中的一句话：“决定我们自身的不是过去的经历，而是我们赋予经历的意义。”书中展示了成熟模式图，即人类成长的三个阶段，依赖期，以“你”为核心，你照顾我，你为我的得失成败负责；独立期，以“我”为核心，我可以做到，我可以负责，我可以靠自己，我有权选择；互赖期，以“我们”为核心，我们可以做到，我们可以合作，我们可以融合、互利、共创。互赖模式是最成熟的相处模式，反思自身，大概我目前只是独立期阶段吧，还需要继续努力提升自己的思维和境界。\n\n书中讲述了七种习惯，贯穿个人自身和人际关系维护的方方面面。我将每种习惯中提取了关键词，做成了[思维导图](https://www.processon.com/view/link/5e1d59e0e4b0c62462a8111e)方便后面的回顾书内内容。\n\n<img src=\"https://wx2.sbimg.cn/2020/04/21/1.png\" style=\"width:100%\">\n\n这本书可以拿出来讲的观点和要素特别多，但我就讲讲让我触动的点吧。\n\n* **做有意义的工作，拒绝“无效努力”，有方法更有方向，才能真正地实现高效**\n  \n第一章中，讲到了把思维方式看作地图。思维方式指的是我们看待世界的方法，也就是我们对世界的理解，通过这种理解诠释了我们的行为。每个人的人生中都存在两种地图，一种是根据实际情况绘制的，一种是根据我们自己的思维方式形成的，后者会造成这种情况：自身主观的理解可能与实际事实上不相符，所以有时再怎么努力照着地图走，却走不到想要去的终点。看到这部分内容，对我的触动还是蛮大的，工作上貌似有时候看起来很忙很努力，结果也只是看起来很忙很努力的样子而已。或者说，忙起来并不困难，难的是要想想自己的思维方式的地图是不是正确导航的，这些比行动更为重要，方向比速度更重要。\n\n* **我见过的优秀的人无不是将自己影响圈内的事情尽可能做到极好**\n  \n关注圈属于我们虽然关心但是没法控制的事情，影响圈是我们能直接影响的事情。比如我们都关心公司的发展越来越好，有良好的产品口碑以及市场占用率，不过这个是我们虽然关心但是无法控制的事情算在关注圈。影响圈内能影响的事情是什么呢？作为前端研发，那么我可以尽我所能把本分工作做好，尽可能提升产品的外观样式、使用性能、交互流畅等等。站在广义的角度上看，如果公司每个岗位的同事都是把自己影响圈的事情做的尽可能好，那么实际上这个圈会逐渐扩大，进而公司的竞争力也会更强。将注意力专注于影响圈内尽可能地做到极致影响圈是会不断变大的，因为它是能被我们控制或影响的，只要我们愿意。\n\n我没法说出来这本书给我所有的收获，很多内容也需要后续反复去看和实践。《高效能人士的七个习惯》确实给我打开了一扇窗，让我看到了解自己还有很长的路要走，让我知道改变自己，要从这四方面去做：\n**1. 生理/身体：锻炼、饮食习惯、休息、压力管理**\n**2. 情感/人际：在重要关系不断“存款”**\n**3. 心智/学识：阅读，学习，总结能力，研究**\n**4. 心灵/心理：价值澄清、沉思、服务**\n\n","tags":["随笔","读后感"]},{"title":"关于正则这件小事","url":"/2020/04/20/关于正则这件小事/","content":"\n[参考链接](https://juejin.im/post/5c7496fdf265da2dda6957d2)","tags":["实战","JavaScript"]},{"title":"关于to九爪小蟹网站的一砖一瓦","url":"/2020/04/17/to九爪小蟹网站的一砖一瓦/","content":"\n### 背景\n\n这个网站的建立是一时兴起，刚好也临近阿庞的生日，可以献出绵薄之力，就当是给阿庞做一个庆生网站。\n\n这篇文章标题是**关于to九爪小蟹网站的一砖一瓦**，因为我要讲的是设计这个网站的全过程，如何一砖一瓦堆砌起来的，也算是一个纪念吧！\n\n---\n\n### 前提准备\n\n#### 1.Base\n一个网站的前提当然是域名解析和服务器部署啦！这个过程比较枯燥，我写了一篇教程：[小白建站全过程](../../15/小白建站全过程（服务器部署-域名解析-静态文件部署）/index.html) ,有兴趣的可以自行移步浏览。\n\n#### 2.需求确立\n\n* **网站形式**：作为一个严肃的生日礼物，那当然是要包含很多惊喜和心意。我的想法是做一个展示类型的网站，主要是适配移动端（~~肯定不是因为我太懒不想适配PC端~~），因为手机在微信里，微博里可以随时打开，但电脑还需要打开电脑 -> 打开浏览器 -> 复制链接 才能访问到网站。\n* **网站架构**: 作为一个严肃的生日礼物，还是根据主流展示类网站形式来做吧 == 主页+菜单+子板块页面。子版块页面通过菜单进入不同板块。\n* **网站内容**: 这方面有后援会各位伙伴绞尽脑汁的出谋划策，基本上是围绕粉丝的祝福（照片，视频）、后援会剪的视频、阿庞的故事进行讨论。作为后援会唯一的开发组成员，面对众多甲方瑟瑟发抖。确定了内容之后，怎么呈现就是我来负责了。\n  \n#### 3.需求分析\n\n* **主页**: 好看！炫酷！开门见山！既然是一个严肃的生日礼物，那主页就做成一个礼物盒拆开，蹦出祝福的形式吧\n* **菜单**：手机端的菜单无非就是顶部或底部分栏切换，或者是一个菜单按钮，点击伸展出全部选项。菜单按钮的方式可以自定义，那就选择菜单按钮吧！（~~绝不是因为我不想做路由管理~~\n* **子版块**:  最重要的页面！要有内容和心意！\n- [ ] 照片墙：可以放粉丝祝福\n- [ ] 阿庞的时间轴：整理阿庞的辩论赛或者其它方面\n- [ ] 关于阿庞的选择故事线，类似心理测试选择，最后得到一个专属结局\n- [ ] 不如做一个游戏吧，翻下仓库的demo，翻牌游戏应该不错\n- [ ] 彩蛋设计\n\n### coding\n作为一个严肃的切图仔，就算没有产品和UI也要给先自己过一遍流程。但也只是在脑海构思一下， 主要的细节还是在开发的过程中去修正。\n#### 1.主页\n\n* 页面设计：\n    + 首先是找礼物盒素材，但发现如果用图片的话没法做到礼物蹦开的动画效果，那我就自己画一个吧。主要思路是①用两个长方形来做礼物盒下部和礼物盖子；②再给礼物盒和盖子加个阴影，增加立体感；③加上礼物盒丝带，看起来有点像了，但感觉还差个蝴蝶结；④可以画两个椭圆来拼接成蝴蝶结（因为css并不能直接画圆，可以通过拉伸圆来生成椭圆）；⑤看起来很像了！⑥动画部分的思路是让盖子和礼物盒下部相反方向摇晃（`translateX`,具体大小由帧数去调整）后，盖子往上方移走，下部往下方移走，然后隐藏。\n  <img src=\"https://wx2.sbimg.cn/2020/04/18/index1.png\" alt=\"礼物图\" style=\"width:200px\"><img src=\"https://wx2.sbimg.cn/2020/04/18/index2.png\" alt=\"礼物图\" style=\"width:200px\"><img src=\"https://wx2.sbimg.cn/2020/04/18/index3.png\" alt=\"礼物图\" style=\"width:200px\"><img src=\"https://wx2.sbimg.cn/2020/04/18/index4.png\" alt=\"礼物图\" style=\"width:200px\"><img src=\"https://wx2.sbimg.cn/2020/04/18/index5.png\" alt=\"礼物图\" style=\"width:200px\">\n    + 礼物盒蹦开后，要设计元素飘出的动画，不然看起来很单调。为了页面性能，找了别人写好的svg图标来用，然后接下来就是比较枯燥的弹出动画，需要对每一行的icon进行动画设计，需要一行行调`translate`和`scale`，不过用了scss还是挺快的。\n  <img src=\"https://wx2.sbimg.cn/2020/04/18/index6.png\" alt=\"礼物图\" style=\"width:200px;margin:0 auto;display:block;\">\n    + 礼物盒打开动画完成后，接下来是下雪动画，这部分用`canvas`来实现，随机生成大小不同，透明度不一样的白色圆球，然后从上往下飘，这部分动画的算法比较复杂，借鉴了别人的写的算法来完善：[Canvas Snow](https://github.com/daveWid/canvas-snow)\n    + 功能函数完成后，就要来写步骤实现了，算好每个动画完成的全部时间，并在完成相应动画后回调下一步函数，并做好步骤判断，方便后面控制流程\n    + 细节完善：主体内容和功能实现后,因为感觉画面有点空，我做了一个关于阿庞的词云（*关键词：799*），加上之后果然饱满了不少。\n   <img src=\"https://wx2.sbimg.cn/2020/04/18/index7.png\" alt=\"礼物图\" style=\"width:100px;margin:0 10px;\"><img src=\"https://wx2.sbimg.cn/2020/04/18/index9.png\" alt=\"礼物图\" style=\"width:100px;\">\n\n* 后续完善：\n  + 后面感觉只有动画有点单调，我加上了背景音乐的播放\n  + 关于词云来做主页感觉有点敷衍，于是就去拜托一个朋友帮我画了阿庞的漫画人物，换了之后果然整个风格可爱了很多\n  + 添加了菜单跳转入口，感觉没有很好的做到引导访问，画蛇添足的加了提示说明，也没有想到更好的引导方式。（果然还是需要产品啊！）\n <img src=\"https://wx2.sbimg.cn/2020/04/18/index10.png\" alt=\"礼物图\" style=\"width:200px;margin:0 auto;display:block;\">\n\n#### 2.照片墙\n\n* 页面设计：\n  + 照片墙一开始的构思是一面墙，上面铺满照片，但我觉得太平淡了，不符合一个严肃的网站。所以，我用了`three.js`。其实就是在网页上放了一个三维坐标轴，然后把一个个粒子放在它该放的位置，加上动画过渡，再架上一个摄像头（也就是你看到的视角），一个炫酷的照片墙就完成了。\n  + 只有单独一种坐标排序当然不符合这个严肃的网站的气质，所以写了球和正方形的坐标算法，在加上799和PY的图形。这个过程就是拼图的过程，因为自定义图形没有规律，所以就只能一个个方格去放，比较繁琐。\n <img src=\"https://wx2.sbimg.cn/2020/04/18/three1.jpg\" alt=\"礼物图\" style=\"width:200px;margin:0 10px;\"><img src=\"https://wx2.sbimg.cn/2020/04/18/three2.jpg\" alt=\"礼物图\" style=\"width:200px;\">\n  + 外壳打造完毕后，就是内容填充了。照片素材的整理是由后援会伙伴们进行的，我没跟她们说清楚，导致图片的尺寸和体积有点大，加载速度就会很慢（毕竟是借来的服务器，带宽是最低配），于是我做了图片加载优化，先批量压缩（[tinyPNG](https://tinypng.com/)），然后图片是以背景图片(`background-image`)来呈现的，这样不用等全部图片加载完毕页面才会继续渲染。（其实应该用雪碧图的方式来做的，但我又~~懒了~~，还要一个个去调背景位置）\n<img src=\"https://wx2.sbimg.cn/2020/04/18/three3.jpg\" alt=\"礼物图\" style=\"width:200px;margin:0 auto;display:block;\">\n  + 接下来最重点的内容了！就是粉丝祝福内容的呈现。我的想法就是点击一个格子，就有一个粉丝的祝福出来。这个也不难写，就是给每个格子加上点击事件，然后粉丝祝福容器出来，替换容器内容，弹出动画就是写几个关键帧。\n<img src=\"https://wx2.sbimg.cn/2020/04/18/three4.jpg\" alt=\"礼物图\" style=\"width:200px;margin:0 auto;display:block;\">\n\n* 后续完善\n  + 首先是关于粉丝祝福数据的数据结构，采用`map`来设计，一个格子对应一个object（name,weibo,[照片]）\n  + 粉丝祝福的照片后面我整理的时候，发现大部分粉丝一人不止发一张，我也不知道要选哪张，那就干脆写一个轮播来展示吧。也就是点击按钮的时候切换背景图片路径\n\n#### 3.小游戏\n\n* 页面设计：\n  + 这个游戏我之前写过demo，于是就直接拿来用。将所有格子随机两两配对，也就是随机给两个格子加上相同的id，相同id的塞入相同的图片，后续的判断就是判断id是否相同来实现配对成功。因为手机屏幕的关系，所以只出了4\\*4，6\\*6，8\\*8的难度（10\\*10已经眼要瞎了，后面是后援会伙伴硬要挑战才加上的）。\n  + 游戏规则逻辑完成后，我加了分数算法，因为之前也没有写过类似的游戏得分算法，也只能自己拿自己来做试验和调试。得分受难度系数，所走步数和所用时间约束，不同的难度对应不同的步数难度系数和时间系数，计算公式可以简化成：`100 - 时间损失 - 步数损失`，小于零分直接算0分。有兴趣的也可以研究或者优化一下    \n  ```javascript\n //传入参数：所用时间，所走步数，难度模式\n    function calcScore(time, step, hards) {\n        let _hard = hards == \"debug\" ? 2 : (hards + 1) * 2 //难度，若是debug模式等于2\n        let fastTime = _hard * 2 * 1000; //假设完成最快的时间,一秒完成一次配对\n        let timeG, stepG; //时间,步数难度系数;\n        switch (_hard) {\n            case 4:\n                timeG = 0.5;\n                stepG = 0.4\n                break\n            case 6:\n                timeG = 0.35;\n                stepG = 0.3;\n                break;\n            case 8:\n                timeG = 0.15;\n                stepG = 0.15;\n                break;\n            case 10:\n                timeG = 0.05;\n                stepG = 0.05;\n                break;\n            default:\n                timeG = 0.8;\n                stepG = 0.5;\n        }\n        let interval = time - fastTime <= 0 ? 0 : time - fastTime; //时间差\n        // 计算公式：100 - 时间损失 - 步数损失，小于零分直接给0分\n        let score = 100 - (interval / 1000.00) * timeG - (step - _hard * 2) * stepG\n        if (score <= 0) {\n            return 0.00\n        }\n        return score.toFixed(2) //取两位小数\n    }\n```\n* 后续完善\n  + 彩蛋设计，如果得分不少于90分，便可以看到彩蛋页面\n\n#### 4.H5多结局测试\n\n* 页面设计\n  + 在头秃之前，写了基本框架和跳转动画，每个新的页面都是动态向`html`推入新的元素，点击不同的按钮塞入的信息不同而已\n  + 接下来是最头疼的故事线设计，还好有后援会伙伴一起肝，两人肝到头都秃了，终于设计好所有结局，于是有下面的流程图\n<img src=\"https://wx2.sbimg.cn/2020/04/18/test1.png\" alt=\"礼物图\" style=\"width:100%;margin:0 auto;display:block;\">\n  + 做完测试后要告诉用户选过的选项，因此这个地方花了多一点时间来实现。一个全局数组来保存每一次点击的选项，然后最后遇到结局便`pop`所有子项\n\n* 后续完善\n  + 这个板块其实不难实现，只是我们设计的流程架构有点大，因此写完测试的时候要把每条故事都走一遍，也是很花时间呀\n\n#### 5.菜单\n\n一开始我是想做炫酷科技风的，最后发现我前面设计的UI其实是可爱风啊（阿庞肯定是粉红少女系呀），所以就把荧光蓝改成荧光粉。主菜单和子菜单的切换其实只是`class`的切换而已，然后链接对应的板块页面入口\n\n#### 6.彩蛋\n\n这个彩蛋是在游戏板块延伸出来的想法，我想做的是像命令行输出的效果，所以用了定时器`setTimeout`来增加文字和延迟文字出现，于是打字的效果出现了。\n\n<img src=\"https://wx2.sbimg.cn/2020/04/18/egg.png\" alt=\"礼物图\" style=\"width:200px;margin:0 auto;display:block;\">\n\n### 展示\n\n**下面就是网站演示了，可以直接点击[这里](http://www.pangying.我爱你)访问**\n\n<br/>\n\n---\n\n*对了，网站网址是http://www.pangying.我爱你*","tags":["技能篇"]},{"title":"小白建站全过程（服务器部署+域名解析+静态文件部署）","url":"/2020/04/15/小白建站全过程（服务器部署-域名解析-静态文件部署）/","content":"\n作为一个前端开发仔，当然不能只专注于网页开发的过程，也要学会如何搭建一个网站。因为朋友在双十一抢到了40元一年的服务器并把帐号密码给了我，那择日不如撞日，就开始学习如何从0到完全搭建一个网站。\n\n此教程分为以下部分：\n\n  1. 前提准备（服务器和域名的购买）\n  2. 服务器部署（nginx）\n  3. 域名解析\n  4. 域名备案\n\n**这篇教程的受众：对于服务器和域名部署解析完全不懂的前端小白**\n\n**看完能收获：一个完整静态网站（只有前端）的建站过程**\n\n\n---\n\n\n### 1. 前提准备\n\n域名和服务器我选择的都是阿里云。因为朋友买的就是阿里云的服务器，我在腾讯云还有一个未过期的已备好案的域名，但是在重新备案和域名解析的时候很麻烦和繁琐。所以建议域名和服务器不要分开在两家买，如果已经是腾讯云域名和阿里云服务器的话，博主悄咪咪的说一句，~~taobao搜腾讯云授权码~~可以快速通过域名备案。\n\n#### 1.1 服务器的选购\n\n![图片](https://wx1.sbimg.cn/2020/04/16/12fa9bac6a1a382d3.png)\n\n对于一般小白用户（博主自己也是），选购服务器可以随便选，具体看预算。我也看了很多选购攻略和问了dalao后，得出以下结论：\n\n  * 购买时注意是否有优惠，一般定期都会有1折购或者双十一这种活动\n  * **实例**：不要选突发性能实例，分为t5和t6，CPU实例为10%和20%起步\n  * 能选ESC虚拟服务器尽量选ESC\n  * **系统**：服务器系统建议Linux系统，因为系统占用磁盘空间很小\n  * **带宽**：1M带宽对于打开一般网页（500kb）也就几秒钟事情\n  * **内存**：个人小站也要1G内存起步吧，500MB有点惨啊\n  * **地域**：看访问客户群集中在哪里，就选择临近的机房；不过境外（比如香港）的机房可以不用备案，境内的要做ICP备案\n  * **需求**：①对于普通的应用服务器，建议选择通用型，CPU内存比为1:4，充分满足各种应用对计算资源的需求；②对于计算能力需要较高的业务，建业选择计算型，CPU内存比为1:2，充分满足对计算速率要求较高的业务\n\n#### 1.2 域名选购\n\n![图片](https://wx1.sbimg.cn/2020/04/15/2.png)\n\n具体域名看个人需求和预算。\n\n*tips：如果要选择中文域名（比如xxx.公司），很多app还不能识别中文域名的访问，比如微信和微博，需要将域名十六进制转码，才能被自动识别成链接，不然只能复制到浏览器访问，且在微信网页/微博网页选择复制链接，网址也是已经被转码过了。*\n\n### 2. 服务器部署\n1. 服务器购买成功后，会得到云服务器的实例名称、公网IP、系统登陆帐号。如果忘记了密码可以去**重置密码**。<br>\n  <img src=\"https://wx2.sbimg.cn/2020/04/15/3.png\" style=\"width:300px;\">\n\n2. 然后**启动实例**，成功启动后可以看到状态时运行中\n\n![图片](https://wx2.sbimg.cn/2020/04/15/4.png)\n\n3. **配置安全组**\n\n![图片](https://wx2.sbimg.cn/2020/04/15/5.png)\n\n配置（开放）常见访问端口：1024/65535（系统对外开放端口，用于远程连接），20/21（ftp服务），80/80（网站访问端口），443/443（https默认端口）\n<img src=\"https://wx2.sbimg.cn/2020/04/15/6.png\" style=\"width:300px;\"><img src=\"https://wx2.sbimg.cn/2020/04/15/7.png\" style=\"width:300px;\">\n<img src=\"https://wx2.sbimg.cn/2020/04/15/8.png\" style=\"width:300px;\"><img src=\"https://wx2.sbimg.cn/2020/04/15/9.png\" style=\"width:300px;\">\n\n4. **远程连接**服务器，关于这步骤有很多方法，我前期用的时阿里云自带的远程连接，后期部署网站文件用了[FileZilla FTP Client](https://filezilla-project.org/)，傻瓜式操作。\n\n* **a) 阿里云远程连接**\n\n![图片](https://wx1.sbimg.cn/2020/04/15/10.png)\n\n* **b) 安装nginx**\n\n我看的是这篇：[在阿里云服务器上如何搭建nginx服务器？](https://yq.aliyun.com/articles/700682)\n\n但第一步是要切换到根目录，然后再根据上面教程进行安装\n\n![图片](https://wx1.sbimg.cn/2020/04/15/11.png)\n\n成功启动nginx后，可以用 ***ps -ef | grep nginx****** ***来查看nginx状态\n\n![图片](https://wx1.sbimg.cn/2020/04/15/12.png)\n\n  * **c) nginx静态文件路径指向**\n    * nginx成功启动后，我们需要修改nginx配置文件，来让服务器访问指向我们自己的网页。所以需要将本地文件上传到服务器上，我用了[FileZilla](https://filezilla-project.org/)来进行上传文件\n ![图片](https://wx1.sbimg.cn/2020/04/15/13.png)\n\n    * 填上服务器主机地址，用户名，密码，端口22，然后连接\n<br><img src=\"https://wx1.sbimg.cn/2020/04/15/14.png\" style=\"width:300px;\">\n\n    * 就能得到我们服务器上的文件目录，然后点击/右键，新建目录data,我的本地文件放在了/data/www/pangying，入口文件时index.html\n<br><img src=\"https://wx1.sbimg.cn/2020/04/15/15.png\" style=\"width:200px;\">\n\n### 3. 域名解析\n\n* 服务器端的指向解决后，需要将访问入口映射到我们购买的域名。\n\n![图片](https://wx1.sbimg.cn/2020/04/15/16.png)\n\n* 添加解析记录\n\n![图片](https://wx1.sbimg.cn/2020/04/15/17.png)\n\n然后访问我们的域名就能成功访问到页面了！但没过多久，你就会发现，页面访问会出现这个画面，提示你域名需要备案了\n![图片](https://wx2.sbimg.cn/2020/04/16/2f9b76cbc65d6d707.png)\n\n### 4. 域名备案\n\n备案可以说是最没有技术含量但是最繁琐的过程。这个过程我可真是一把辛酸泪，一两年前我也有域名备案过，腾讯云的，申请备案，然后按规定填写信息，用寄来的蓝色布拍照，手写审核书，提交，很顺利就通过了。\n\n* 首先要先申请服务号\n   \n![图片](https://wx2.sbimg.cn/2020/04/16/3.png)\n\n![图片](https://wx2.sbimg.cn/2020/04/16/4.png)\n\n然后将备案服务号保存，域名备案需要用到\n\n![图片](https://wx1.sbimg.cn/2020/04/16/51566e15f3d270519.png)\n\n\n接下来就是在手机上下载阿里云app，因为需要用到手机摄像头来人像识别，所以不如就直接在app上操作就行。\n然后根据提示，一步步操作就行，一般1-3个工作日就会有阿里的工作人员来打电话跟你核验，通过之后会发邮件通知审核通过。\n\n![图片](https://wx2.sbimg.cn/2020/04/16/7.png)\n\n*注意：我的审核前两次都没通过，第一次是因为网站名称带了人名+拍照的时候眼镜闭上了+名下还有一个域名没指向实体(也就是无法访问了)；第二次是因为网站描述内容没写好，这些要求在申请的时候要注意看清楚，一次审核不通过会延迟1-3个工作日的进度*\n\n收到邮件通知通过后，网站就可以正常访问啦！\n至于网站的内容这边就不多赘述了，毕竟这是个正经的教程。\n","tags":["技能篇"]}]