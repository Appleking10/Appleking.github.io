---
title: 程序员必备算法基础
date: 2020-06-18 14:43:15
tags: [前端基础,技能篇]
---
### 一.复杂度

#### 1. 复杂度是什么

**复杂度**是衡量代码运行效率的重要的度量因素。
先看一下**复杂度**和计算机**实际任务处理效率**的关系，从而了解降低复杂度的必要性。

计算机通过一个个程序去执行计算任务，也就是对输入数据进行加工处理，并最终得到结果的过程。每个程序都是由代码构成的。可见，编写代码的核心就是要完成计算。但对于同一个计算任务，不同计算方法得到结果的过程复杂程度是不一样的，这对你实际的任务处理效率就有了非常大的影响。
举个例子，你要在一个在线系统中实时处理数据。假设这个系统平均每分钟会新增 300M 的数据量。如果你的代码不能在 1 分钟内完成对这 300M 数据的处理，那么这个系统就会发生时间爆炸和空间爆炸。表现就是，电脑执行越来越慢，直到死机。因此，我们需要讲究合理的计算方法，去通过尽可能低复杂程度的代码完成计算任务。

那如何降低复杂程度呢，我们首先需要知道怎么衡量复杂度。而在实际衡量时，我们通常会围绕以下2 个维度进行。
首先，*这段代码消耗的资源是什么*。一般而言，代码执行过程中会消耗计算时间和计算空间，那需要衡量的就是
* 时间复杂度
* 空间复杂度。

其次，*这段代码对于资源的消耗是多少*。不能只看当前资源消耗了多少，因为不管是时间还是空间，它们的消耗都和输入量有很大关系。为了更客观地衡量消耗程度，我们通常会关注时间或者**空间消耗量**与**输入数据量**之间的关系。

复杂度是一个关于输入数据量 n 的函数。假设你的代码复杂度是 f(n)，即 O(f(n))。例如，O(n) 表示的是，复杂度与计算实例的个数 n 线性相关；O(logn) 表示的是，复杂度与计算实例的个数 n 对数相关。

通常，复杂度的计算方法遵循以下几个原则：
* 首先，复杂度与具体的常系数无关，例如 O(n) 和 O(2n) 表示的是同样的复杂度。我们详细分析下，O(2n) 等于 O(n+n)，也等于 O(n) + O(n)。也就是说，一段 O(n) 复杂度的代码只是先后执行两遍 O(n)，其复杂度是一致的。
* 其次，多项式级的复杂度相加的时候，选择高者作为结果，例如 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。具体分析一下就是，O(n²)+O(n) = O(n²+n)。随着 n 越来越大，二阶多项式的变化率是要比一阶多项式更大的。因此，只需要通过更大变化率的二阶多项式来表征复杂度就可以了。

> O(1) 也是表示一个特殊复杂度，含义为某个任务通过有限可数的资源即可完成。此处有限可数的具体意义是:数据量多少和资源消耗无关。

#### 2.时间复杂度与代码结构的关系

代码的时间复杂度，与代码的结构有非常强的关系。举个栗子：

```javascript
function getMaxVal(arr) {
    let max_val = -1;
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] > max_val) {
            max_val = a[i];
        }
    }
    return max_val
}
```
暂存当前最大值并把所有元素遍历一遍即可。因为代码的结构上需要使用一个 for 循环，对数组所有元素处理一遍，所以时间复杂度为 O(n)。

下面的代码定义了一个数组 a = [1, 3, 4, 3, 4, 1, 3]，并会在这个数组中查找出现次数最多的那个数字
```javascript
function getMostVal(arr = [1, 3, 4, 3, 4, 1, 3 ] ) {
    let val_max = -1;
    let time_max = 0;
    let time_tmp = 0;
    for (int i = 0; i < arr.length; i++) {
        time_tmp = 0;
        for (let j = 0; j < arr.length; j++) {
            if (arr[i] == arr[j]) {
            time_tmp += 1;
        }
        if (time_tmp > time_max) {
            time_max = time_tmp;
            val_max = arr[i];
        }
        }
    }
   return val_max;
}
```
这段代码中，我们采用了两重循环的方式计算：第一层循环，对数组中每个元素进行遍历；第二层循环，对于每个元素计算出现的次数，并且通过当前元素次数 `time_tmp` 和全局最大次数变量 `time_max` 的大小关系，保存出现次数最多的那个元素及其出现次数。由于是两重循环，这段代码在时间复杂度是 n*n，也就是 O(n²)。

通过一些经验，我们可以得出一些结论：
* 一个顺序结构的代码，时间复杂度是 O(1)。
* 二分查找（分而治之的二分策略），时间复杂度都是 O(logn)。
* 一个简单的 for 循环，时间复杂度是 O(n)。
* 两个顺序执行的 for 循环，时间复杂度是 O(n)+O(n)=O(2n)，其实也是 O(n)。
* 两个嵌套的 for 循环，时间复杂度是 O(n²)。

#### 3.降低时间复杂度的必要性

假设某个计算任务需要处理 10万 条数据。你编写的代码：
* 如果是 O(n²) 的时间复杂度，那么计算的次数就大概是 100 亿次左右。
* 如果是 O(n)，那么计算的次数就是 10万 次左右。
* 如果这个工程师再厉害一些，能在 O(log n) 的复杂度下完成任务，那么计算的次数就是 17 次左右。
 
通常在小数据量的计算上，时间复杂度的降低在绝对处理时间上没有太多体现。但在当今的大数据环境下，时间复杂度的优化将会带来巨大的系统收益。

### 二.学会将时间复杂度转换成空间复杂度

在两全其美的情况下，要采用尽可能低的时间复杂度和空间复杂度，去完成一段代码的开发。但有时候只能选择牺牲一部分来找到最佳编码方法。

#### 要诀：时间昂贵、空间廉价
一段代码会消耗计算时间、资源空间，从而产生时间复杂度和空间复杂度。
假设一段代码经过优化后，虽然降低了时间复杂度，但依然需要消耗非常高的空间复杂度。 例如，对于固定数据量的输入，这段代码需要消耗几十 G 的内存空间，很显然普通计算机根本无法完成这样的计算。如果一定要解决的话，一个最简单粗暴的办法就是，购买大量的高性能计算机，来弥补空间性能的不足。
这告诉我们一个什么样的现实问题呢？代码效率的瓶颈可能发生在时间或者空间两个方面。如果是缺少计算空间，花钱买服务器就可以了。这是个花钱就能解决的问题。相反，如果是缺少计算时间，只能投入**宝贵的人生**去跑程序。即使你有再多的钱、再多的服务器，也是毫无用处。相比于空间复杂度，时间复杂度的降低就显得更加重要了。因此，你会发现这样的结论：**空间是廉价的，而时间是昂贵的。**

#### 程序优化的具体思路：

* 第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。

* 第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。

* 第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。

举个栗子：
假设有任意多张面额为 2 元、3 元、7 元的货币，现要用它们凑出 100 元，求总共有多少种可能性。
```javascript
// 暴力解法：
function computeTotal() {
    let count = 0;
    for (let i = 0; i <= (100 / 7); i++) {
        for (let j = 0; j <= (100 / 3); j++) {
            for (let k = 0; k <= (100 / 2); k++) {
                if (i * 7 + j * 3 + k * 2 == 100) {
                    count += 1;
                }
            }
        }
    }
    return count
}`
```
在这段代码中，使用了 3 层的 for 循环。从结构上来看，是很显然的 O( n³ ) 的时间复杂度。然而，仔细观察就会发现，代码中最内层的 for 循环是多余的。因为，当确定了要用 i 张 7 元和 j 张 3 元时，只需要判断用有限个 2 元能否凑出 100 - 7* i - 3* j 元就可以了。因此，代码可以改进一下：

```javascript
function computeTotal() {
    let count = 0;
    for (let i = 0; i <= (100 / 7); i++) {
        for (let j = 0; j <= (100 / 3); j++) {
            if ((100 - i  *7 - j * 3 >= 0)&&((100 - i * 7 - j * 3) % 2 == 0)) {
                count += 1;
            }
        }
    }
   return count;
}
```
很显然，时间复杂度就变成了O(n²)。